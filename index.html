<!DOCTYPE html>
<html>
<head>
    <title>Echoes of Aincrad</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Attempt to load custom font */
        @font-face {
            font-family: 'Enchant';
            src: url('Fonts/Enchant.woff2') format('woff2'),
                 url('Fonts/Enchant.woff') format('woff'),
                 url('Fonts/Enchant.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
        }

        /* --- Basic Body and Font Styles --- */
        body {
            color: #ecf0f1;
            font-family: 'Inter', Arial, Helvetica, sans-serif;
            line-height: 1.5;
            margin: 0;
            padding: 0;
            background-image: url('Images/forest.jpg');
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            background-position: center;
            background-color: #2c3e50;
            text-align: center;
            padding: 15px;
            box-sizing: border-box;
            position: relative;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* Align content to top */
            overflow-y: auto; /* Allow vertical scroll if content overflows */
        }

        /* --- Screen Management --- */
        .screen {
            width: 100%;
            max-width: 1200px;
            display: none;
            flex-direction: column;
            align-items: center;
            box-sizing: border-box;
            margin-top: 20px;
        }
        .screen.active {
            display: flex;
        }

        /* --- Start Screen Styles --- */
        #start-screen {
            background-color: rgba(44, 62, 80, 0.9);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            gap: 20px;
            margin-top: auto;
            margin-bottom: auto;
        }
        #start-screen h1 {
            margin-bottom: 20px;
            font-family: 'Enchant', 'Inter', sans-serif;
            font-weight: normal;
        }
        .start-section {
            width: 100%;
            max-width: 500px;
            margin-bottom: 20px;
        }
        #character-creation h2 {
            color: #f1c40f;
            border-bottom: 1px solid #7f8c8d;
            padding-bottom: 10px;
            margin-bottom: 20px;
            text-align: center;
        }
        #character-selection { text-align: center; margin-bottom: 25px; }
        #character-selection h3 { margin-bottom: 15px; }
        #character-selection label { margin: 0 10px; cursor: pointer; font-size: 1.1em;}
        #character-selection input[type="radio"] { margin-right: 5px; cursor: pointer; transform: scale(1.1); }

        .placeholder-section {
            background-color: rgba(52, 73, 94, 0.8);
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            border: 1px dashed #7f8c8d;
        }
        .placeholder-section h3 { margin-top: 0; margin-bottom: 10px; color: #bdc3c7;}
        .placeholder-section p, .placeholder-section select { color: #95a5a6; }
        #class-select { padding: 5px; border-radius: 3px; background-color: #7f8c8d; color: #bdc3c7;}

        #start-game-button {
            padding: 12px 25px;
            font-size: 1.1em;
            background-color: #27ae60;
            color: white;
            margin-top: 10px;
        }
        #start-game-button:hover { background-color: #2ecc71; }

        /* --- Game Screen Styles --- */
        #game-screen {
             gap: 15px;
        }

        /* Top Control Bar */
        #top-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            width: 100%;
            max-width: 700px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }
        #top-controls button {
            background-color: #95a5a6;
            color: #2c3e50;
            padding: 8px 12px;
            font-size: 0.85em;
        }
        #top-controls button:hover { background-color: #bdc3c7; }

        /* --- Game Area (within Game Screen) --- */
        #game-area {
            width: 100%;
            padding: 15px;
            background-color: rgba(52, 73, 94, 0.9);
            border: 1px solid #7f8c8d;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        /* --- General Row Styling --- */
        .game-row { display: flex; gap: 15px; width: 100%; box-sizing: border-box; flex-shrink: 0; }
        #stats-row {
            justify-content: space-around;
            align-items: flex-start; /* Align items to the top */
            flex-wrap: wrap;
        }
        #message-row { /* No specific styles */ }
        #action-row { justify-content: center; flex-wrap: wrap; flex-shrink: 0; }


        /* --- Stats Blocks & Inventory Column --- */
        .stats-block, .inventory-column { /* Shared styles */
            flex-grow: 1;
            flex-shrink: 1;
            background-color: rgba(44, 62, 80, 0.9);
            padding: 15px;
            border-radius: 5px;
            border: 1px dashed #7f8c8d; /* Dashed border for all */
            min-width: 200px;
            box-sizing: border-box;
            margin-bottom: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* Specific widths */
        .stats-block {
            flex-basis: 200px;
            max-width: 260px;
        }
        .inventory-column {
             background-color: rgba(52, 73, 94, 0.85);
             flex-basis: 340px;
             max-width: 450px;
             min-width: 280px;
             gap: 10px;
        }

        .stats-block h2, .inventory-column h3 { /* Shared heading style */
             margin-top: 5px;
             margin-bottom: 8px;
             display: inline-block;
             margin-right: 5px;
             width: 100%;
             text-align: center;
             color: #f1c40f;
        }
        .inventory-column h3 { /* Specific inventory heading */
             border-bottom: 1px dashed #7f8c8d;
             padding-bottom: 5px;
             margin-bottom: 10px;
        }
        .debuff-indicator {
            font-size: 0.8em;
            color: #e74c3c;
            font-weight: bold;
            vertical-align: middle;
        }
        .stats-block img { /* General image style */
            max-width: 80px;
            height: auto;
            display: block;
            border-radius: 4px;
            background-color: #34495e;
            flex-shrink: 0;
            margin-bottom: 10px;
            margin-left: auto;
            margin-right: auto;
         }
        .stats-block p {
            margin: 3px 0;
            font-size: 0.95em;
            width: 100%;
            text-align: center;
        }
        #player-hp, #enemy-hp { font-weight: bold; font-size: 1.05em; color: #2ecc71; }
        #player-dodge, #enemy-dodge { font-weight: bold; }


        /* --- Equipment Display Row Styles --- */
        #equipment-row { justify-content: space-around; align-items: center; flex-wrap: wrap; background-color: rgba(44, 62, 80, 0.7); padding: 8px 10px; border-radius: 5px; border: 1px solid #566573; }
        .equip-slot { color: #bdc3c7; font-size: 0.9em; padding: 5px; text-align: center; min-width: 100px; }
        .equip-slot span { color: #f1c40f; font-weight: bold; display: block; margin-top: 2px; }
        .equip-slot .item-tier-low { color: #ecf0f1; }
        .equip-slot .item-tier-mid { color: #3498db; }
        .equip-slot .item-tier-high { color: #f1c40f; }
        .equip-slot .item-tier-champion { color: #e74c3c; }


        /* --- Message Log Styling --- */
        #message-log { background-color: rgba(44, 62, 80, 0.9); border: 1px dashed #7f8c8d; padding: 15px; border-radius: 5px; display: flex; flex-direction: column; overflow: hidden; height: auto; box-sizing: border-box; width: 100%; }
        #message { margin: 0; line-height: 1.6; height: 180px; overflow-y: auto; padding-right: 5px; text-align: left; margin-bottom: 10px; word-wrap: break-word; border: 1px solid #566573; background-color: rgba(0, 0, 0, 0.1); flex-shrink: 0; }
        #message p { margin: 2px 0; }
        .item-comparison { border-left: 3px solid #f39c12; padding-left: 8px; margin: 5px 0; font-size: 0.9em; }
        .item-comparison strong { color: #f1c40f; }
        .item-comparison .stat-name { color: #bdc3c7; }
        .item-comparison .stat-value { color: #ecf0f1; font-weight: bold; }
        .item-comparison .positive { color: #2ecc71; }
        .item-comparison .negative { color: #e74c3c; }
        .item-tier-low { color: #ecf0f1; font-weight: bold; }
        .item-tier-mid { color: #3498db; font-weight: bold; }
        .item-tier-high { color: #f1c40f; font-weight: bold; }
        .item-tier-champion { color: #e74c3c; font-weight: bold; }
        .critical-hit { color: #f1c40f; font-weight: bold; font-style: italic; }


        /* Score Info Container Styling */
        #score-info-container { display: flex; justify-content: space-between; align-items: center; padding: 8px 10px; background-color: rgba(52, 73, 94, 0.95); color: #f1c40f; border-top: 1px solid #7f8c8d; border-radius: 0 0 4px 4px; font-weight: bold; font-size: 0.95em; flex-shrink: 0; margin: 0 -15px -15px -15px; padding-left: 15px; padding-right: 10px; text-align: left; flex-wrap: wrap; gap: 5px; }
        #current-score-display, #high-score-display { margin-right: 10px; }
        #reset-highscore-button { padding: 3px 8px; font-size: 0.8em; font-weight: normal; background-color: #e74c3c; color: white; border: none; border-radius: 3px; cursor: pointer; transition: background-color 0.2s ease; min-width: auto; margin-left: auto; }
        #reset-highscore-button:hover { background-color: #c0392b; }

        /* --- Actions Container --- */
        #actions { background-color: rgba(44, 62, 80, 0.9); padding: 10px 15px; border-radius: 5px; text-align: center; width: fit-content; margin-left: auto; margin-right: auto; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }


        /* --- Headings --- */
        h1 { text-align: center; color: #ecf0f1; margin-top: 0; margin-bottom: 15px; background-color: transparent; padding: 0; display: block; font-size: 2.2em; }
        h3 { color: #ecf0f1; margin-top: 0; margin-bottom: 10px; font-size: 1.1em; }

        /* --- Buttons --- */
        button { padding: 10px 18px; margin: 5px; font-size: 0.95em; font-weight: bold; cursor: pointer; border: none; border-radius: 5px; transition: background-color 0.2s ease, transform 0.1s ease; min-width: 90px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); line-height: 1.2; }
        button:active { transform: translateY(1px); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        #horizontal-button { background-color: #c0392b; color: white; }
        #horizontal-button:hover { background-color: #e74c3c; }
        #evasion-button { background-color: #00bcd4; color: white; }
        #evasion-button:hover { background-color: #26c6da; }
        #first-aid-button { background-color: #27ae60; color: white; }
        #first-aid-button:hover { background-color: #2ecc71; }
        .skill-button { background-color: #8e44ad; color: white; }
        .skill-button:hover { background-color: #9b59b6; }
        .flee-button { background-color: #f39c12; color: white; }
        .flee-button:hover { background-color: #e67e22; }
        button:disabled { background-color: #7f8c8d; color: #bdc3c7; cursor: not-allowed; box-shadow: none; transform: none; }
        #equip-button { background-color: #27ae60; color: white; }
        #equip-button:hover { background-color: #2ecc71; }
        #discard-button { background-color: #e74c3c; color: white; }
        #discard-button:hover { background-color: #c0392b; }


        /* --- Hidden Class --- */
        .hidden { display: none !important; }

        /* --- Special Message Styles --- */
        .special-message { font-weight: bold; font-size: 1.05em; padding: 3px 6px; border-radius: 4px; margin: 3px 0; display: inline-block; width: calc(100% - 12px); box-sizing: border-box; }
        .skill-learned-message { color: #f1c40f; background-color: rgba(44, 62, 80, 0.8); border-left: 4px solid #f1c40f; }
        .item-drop-message { color: #3498db; background-color: rgba(44, 62, 80, 0.8); border-left: 4px solid #3498db; }
        .debuff-applied-message { color: #e74c3c; background-color: rgba(44, 62, 80, 0.8); border-left: 4px solid #e74c3c; }
        .debuff-faded-message { color: #95a5a6; background-color: rgba(44, 62, 80, 0.8); border-left: 4px solid #95a5a6; }
        .burn-message { color: #e67e22; background-color: rgba(44, 62, 80, 0.8); border-left: 4px solid #e67e22; }


        /* --- Tooltip Styles --- */
        .tooltip { position: absolute; background-color: rgba(44, 62, 80, 0.95); color: #ecf0f1; border: 1px solid #7f8c8d; border-radius: 5px; padding: 8px 12px; font-size: 0.9em; line-height: 1.4; max-width: 250px; text-align: left; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); z-index: 100; pointer-events: none; white-space: normal; }

        /* --- Integrated Inventory Styles --- */
        /* .inventory-column defined above with .stats-block */
        .inventory-section {
            background-color: rgba(44, 62, 80, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #566573;
            width: 100%;
            box-sizing: border-box;
        }
        .inventory-section h3 { /* Already styled above */ }

        .inventory-top-row {
            display: flex;
            gap: 10px;
            width: 100%;
            align-items: flex-start; /* Align tops of inner sections */
        }
        .inventory-top-row .inventory-section {
            flex: 1; /* Share space */
            margin-bottom: 0;
        }

        /* Equipped items styling */
        .equipped-item-slot { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .equipped-item-slot img { width: 30px; height: 30px; border-radius: 3px; background-color: #34495e; flex-shrink: 0; object-fit: cover; }
        .equipped-item-slot .item-name { font-size: 0.9em; flex-grow: 1; }

        /* Backpack grid styling */
        #backpack-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(45px, 1fr)); /* Target 4 columns */
            gap: 5px;
            min-height: 100px;
            max-height: 150px;
            overflow-y: auto;
            padding: 5px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        .backpack-slot {
            aspect-ratio: 1 / 1;
            background-color: #34495e;
            border: 1px solid #7f8c8d;
            border-radius: 4px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .backpack-slot:hover { border-color: #f1c40f; }
        .backpack-slot.empty { background-color: rgba(44, 62, 80, 0.5); cursor: default; }
        .backpack-slot img { max-width: 90%; max-height: 90%; object-fit: contain; pointer-events: none; }
        .backpack-slot.selected { border-color: #2ecc71; box-shadow: 0 0 5px #2ecc71; }

        /* Item details & comparison styling */
        #item-details-section { /* Target the specific section */
             margin-top: 0; /* Reset top margin */
        }
        /* New container for side-by-side comparison */
        .item-comparison-container {
            display: flex;
            gap: 10px; /* Space between comparison boxes */
            margin-bottom: 10px; /* Space below comparison */
        }
        /* Style for individual comparison boxes */
        #equipped-item-comparison,
        #selected-item-details {
            flex: 1; /* Share space equally */
            text-align: left;
            min-height: 60px; /* Match original details height */
        }
        #equipped-item-comparison h4,
        #selected-item-details h4 {
            margin-top: 0;
            margin-bottom: 5px;
            color: #ecf0f1;
            font-size: 0.9em; /* Slightly smaller heading */
            border-bottom: 1px dotted #7f8c8d;
            padding-bottom: 3px;
        }
        #equipped-item-comparison ul,
        #selected-item-details ul {
            list-style: none;
            padding: 0;
            margin: 0;
            font-size: 0.85em;
        }
         #equipped-item-comparison li,
         #selected-item-details li {
             margin-bottom: 2px;
             color: #95a5a6;
         }
         #equipped-item-comparison li strong,
         #selected-item-details li strong {
            color: #ecf0f1;
            margin-right: 4px;
         }
        #item-detail-actions { /* Center the buttons below comparison */
            text-align: center;
        }
        #item-detail-actions button { font-size: 0.85em; padding: 4px 8px; min-width: 60px; }


        /* --- Responsive Adjustments --- */
        @media (max-width: 850px) { /* Adjust breakpoint for 3 columns */
            .stats-block, .inventory-column { min-width: 180px; flex-basis: 45%; max-width: none; } /* Allow 2 columns */
            .inventory-column { order: 1; }
            #player-stats { order: 0; }
            #enemy-stats { order: 2; }
        }
        @media (max-width: 600px) { /* Smaller Tablet / Large Mobile */
             .stats-block, .inventory-column { flex-basis: 100%; max-width: none; } /* Stack all 3 columns */
             #player-stats, #inventory-display, #enemy-stats { order: 0; } /* Reset order for stacking */
             .inventory-top-row { flex-direction: column; } /* Stack equipped/backpack vertically */
             .item-comparison-container { flex-direction: column; } /* Stack comparison boxes */
             #equipment-row { flex-direction: column; align-items: center; }
             .equip-slot { min-width: 150px; }
             #message { height: 150px; } /* Further reduce message height */
             #start-screen { padding: 15px; }
             h1 { font-size: 1.6em; }
             #character-selection label { font-size: 1em; margin: 0 5px;}
             #character-selection input[type="radio"] { transform: scale(1.0); }
             button { padding: 8px 15px; font-size: 0.9em; }
             #start-game-button { font-size: 1em; }
             #player-stats { padding-top: 10px; }
             #player-stats h2 { margin-top: 5px; }
             #player-stats p { font-size: 0.9em; }
             #backpack-grid { grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); gap: 5px; }
             .backpack-slot { width: 50px; height: 50px; }
        }
    </style>
</head>
<body>

    <div id="start-screen" class="screen active">
        <h1>Echoes of Aincrad</h1>
        <div class="start-section" id="character-creation">
            <h2>Create Your Character</h2>
            <div id="character-selection">
                <h3>Choose Appearance:</h3>
                <label><input type="radio" name="playerChoice" value="Images/male.jpg"> Male</label>
                <label><input type="radio" name="playerChoice" value="Images/female.jpg"> Female</label>
                <label><input type="radio" name="playerChoice" value="Images/they_them.jpg" checked> They/Them</label>
            </div>
            <div class="placeholder-section">
                <h3>Choose Class:</h3>
                <select id="class-select" disabled>
                    <option>Swordsman (Default)</option>
                </select>
                <p>(Class selection coming soon!)</p>
            </div>
            <div class="placeholder-section">
                <h3>Starting Weapon:</h3>
                <p>One-Handed Sword (Default)</p>
             </div>
            <button id="start-game-button">Start Game</button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div id="top-controls">
             <button id="new-character-button">New Character</button>
             <button id="reset-button">Start Over</button>
             </div>
        <div id="game-area">
            <div class="game-row" id="stats-row">
                <div id="player-stats" class="stats-block">
                    <img id="player-image" src="Images/they_them.jpg" alt="Player Character" onerror="this.onerror=null; this.src='https://placehold.co/80x80/34495e/ecf0f1?text=Player';">
                    <h2>Player <span class="debuff-indicator" id="player-debuff-indicator"></span></h2>
                    <p>Level: <span id="player-level">1</span></p>
                    <p>HP: <span id="player-hp">100</span> / <span id="player-max-hp">100</span></p>
                    <p>XP: <span id="player-xp">0</span> / <span id="player-xp-needed">100</span></p>
                    <p>STR: <span id="player-str">5</span></p>
                    <p>DEF: <span id="player-def">4</span></p>
                    <p>Dodge: <span id="player-dodge">5.0</span>%</p>
                    <p>Crit Chance: <span id="player-crit-chance">5.0</span>%</p>
                    <p>Crit Damage: <span id="player-crit-damage">150</span>%</p>
                    <p>Damage: <span id="player-min-dmg">7</span> - <span id="player-max-dmg">12</span></p>
                </div>

                <div id="inventory-display" class="inventory-column">
                    <div class="inventory-top-row">
                        <div class="inventory-section"> <h3>Equipped</h3>
                            <div id="inventory-equipped-weapon" class="equipped-item-slot">
                                <img src="https://placehold.co/40x40/a52a2a/eee?text=WPN" alt="Weapon Slot">
                                <span class="item-name">Weapon: <span class="item-tier-low">None</span></span>
                            </div>
                            <div id="inventory-equipped-armor" class="equipped-item-slot">
                                <img src="https://placehold.co/40x40/708090/eee?text=ARM" alt="Armor Slot">
                                <span class="item-name">Armor: <span class="item-tier-low">None</span></span>
                            </div>
                            <div id="inventory-equipped-accessory" class="equipped-item-slot">
                                <img src="https://placehold.co/40x40/ffd700/333?text=ACC" alt="Accessory Slot">
                                <span class="item-name">Accessory: <span class="item-tier-low">None</span></span>
                            </div>
                        </div>
                        <div class="inventory-section"> <h3>Backpack (<span id="backpack-count">0</span>/<span id="backpack-max">0</span>)</h3>
                            <div id="backpack-grid">
                                </div>
                        </div>
                    </div>
                    <div id="item-details-section" class="inventory-section">
                        <h3>Item Details</h3>
                        <div class="item-comparison-container">
                            <div id="equipped-item-comparison">
                                <h4>Currently Equipped</h4>
                                <p>N/A</p>
                            </div>
                            <div id="selected-item-details">
                                <h4>Selected Item</h4>
                                <p>Select an item from backpack.</p>
                            </div>
                        </div>
                        <div id="item-detail-actions" class="hidden">
                            <button id="equip-button">Equip</button>
                            <button id="discard-button">Discard</button>
                        </div>
                    </div>
                </div>

                <div id="enemy-stats" class="stats-block">
                     <img id="enemy-image" src="Images/boar.jpg" alt="Enemy Character" onerror="this.onerror=null; this.src='https://placehold.co/80x80/2c3e50/ecf0f1?text=Enemy';">
                     <h2 id="enemy-name">Enemy</h2> <span class="debuff-indicator" id="enemy-debuff-indicator"></span>
                    <p>HP: <span id="enemy-hp">100</span> / <span id="enemy-max-hp">100</span></p>
                    <p>STR: <span id="enemy-str">3</span></p>
                    <p>DEF: <span id="enemy-def">2</span></p>
                    <p>Dodge: <span id="enemy-dodge">5</span>%</p>
                </div>
            </div>
            <div class="game-row" id="equipment-row">
                <div class="equip-slot">Weapon: <span id="equipped-weapon">None</span></div>
                <div class="equip-slot">Armor: <span id="equipped-armor">None</span></div>
                <div class="equip-slot">Accessory: <span id="equipped-accessory">None</span></div>
            </div>
            <div class="game-row" id="message-row">
                 <div id="message-log">
                    <div id="message">Welcome!</div>
                    <div id="score-info-container">
                         <div id="current-score-display">Current Level: <span id="current-level-value">1</span></div>
                         <div id="high-score-display">Highest Level: <span id="high-score-value">0</span></div>
                         <button id="reset-highscore-button" title="Reset High Score">Reset HS</button>
                    </div>
                </div>
            </div>
            <div class="game-row" id="action-row">
                <div id="actions">
                    <button id="horizontal-button">Horizontal<br>Strike</button>
                    <button id="horizontal-arc-button" class="skill-button hidden">Horizontal Arc</button>
                    <button id="horizontal-square-button" class="skill-button hidden">Horizontal Square</button>
                    <button id="deadly-sins-button" class="skill-button hidden">Deadly Sins</button>
                    <button id="evasion-button">Evasion</button>
                    <button id="first-aid-button">First Aid</button>
                    <button id="flee-button" class="flee-button hidden">Flee</button>
                </div>
            </div>
            </div>
     </div>
     <div id="tooltip" class="tooltip hidden"></div>

     <script>
        // --- DOM Elements ---
        // Screens
        const startScreen = document.getElementById('start-screen');
        const gameScreen = document.getElementById('game-screen');
        // Start Screen
        const startGameButton = document.getElementById('start-game-button');
        const playerChoiceRadios = document.querySelectorAll('input[name="playerChoice"]');
        // Top Controls
        const resetButton = document.getElementById('reset-button');
        const newCharacterButton = document.getElementById('new-character-button');
        // Actions
        const horizontalButton = document.getElementById('horizontal-button');
        const evasionButton = document.getElementById('evasion-button');
        const firstAidButton = document.getElementById('first-aid-button');
        const horizontalArcButton = document.getElementById('horizontal-arc-button');
        const horizontalSquareButton = document.getElementById('horizontal-square-button');
        const deadlySinsButton = document.getElementById('deadly-sins-button');
        const fleeButton = document.getElementById('flee-button');
        const actionRow = document.getElementById('action-row');
        // Tooltip
        const tooltipElement = document.getElementById('tooltip');
        // Equipment Display (In-Game)
        const equippedWeaponElement = document.getElementById('equipped-weapon');
        const equippedArmorElement = document.getElementById('equipped-armor');
        const equippedAccessoryElement = document.getElementById('equipped-accessory');
        // Message Log & Score
        const messageElement = document.getElementById('message');
        const messageLogElement = document.getElementById('message-log');
        const highScoreValueElement = document.getElementById('high-score-value');
        const currentLevelValueElement = document.getElementById('current-level-value');
        const resetHighScoreButton = document.getElementById('reset-highscore-button');
        // Player Stats Display
        const playerHpElement = document.getElementById('player-hp');
        const playerMaxHpElement = document.getElementById('player-max-hp');
        const playerStrElement = document.getElementById('player-str');
        const playerDefElement = document.getElementById('player-def');
        const playerDodgeElement = document.getElementById('player-dodge');
        const playerImageElement = document.getElementById('player-image');
        const playerLevelElement = document.getElementById('player-level');
        const playerXpElement = document.getElementById('player-xp');
        const playerXpNeededElement = document.getElementById('player-xp-needed');
        const playerCritChanceElement = document.getElementById('player-crit-chance');
        const playerCritDamageElement = document.getElementById('player-crit-damage');
        const playerMinDmgElement = document.getElementById('player-min-dmg');
        const playerMaxDmgElement = document.getElementById('player-max-dmg');
        const playerDebuffIndicator = document.getElementById('player-debuff-indicator');
        const playerStatsBlock = document.getElementById('player-stats');
        // Enemy Stats Display
        const enemyHpElement = document.getElementById('enemy-hp');
        const enemyMaxHpElement = document.getElementById('enemy-max-hp');
        const enemyStrElement = document.getElementById('enemy-str');
        const enemyDefElement = document.getElementById('enemy-def');
        const enemyDodgeElement = document.getElementById('enemy-dodge');
        const enemyNameElement = document.getElementById('enemy-name');
        const enemyImageElement = document.getElementById('enemy-image');
        const enemyDebuffIndicator = document.getElementById('enemy-debuff-indicator');
        const enemyStatsBlock = document.getElementById('enemy-stats');
        // --- Integrated Inventory Elements ---
        const inventoryDisplay = document.getElementById('inventory-display');
        const invEquippedWeapon = document.getElementById('inventory-equipped-weapon').querySelector('.item-name');
        const invEquippedArmor = document.getElementById('inventory-equipped-armor').querySelector('.item-name');
        const invEquippedAccessory = document.getElementById('inventory-equipped-accessory').querySelector('.item-name');
        const invEquippedWeaponImg = document.getElementById('inventory-equipped-weapon').querySelector('img');
        const invEquippedArmorImg = document.getElementById('inventory-equipped-armor').querySelector('img');
        const invEquippedAccessoryImg = document.getElementById('inventory-equipped-accessory').querySelector('img');
        const backpackGrid = document.getElementById('backpack-grid');
        const backpackCountSpan = document.getElementById('backpack-count');
        const backpackMaxSpan = document.getElementById('backpack-max');
        const itemDetailsSection = document.getElementById('item-details-section'); // Container for comparison + actions
        const equippedItemComparisonDiv = document.getElementById('equipped-item-comparison'); // New div for equipped stats
        const selectedItemDetailsDiv = document.getElementById('selected-item-details'); // Renamed original details div
        const itemDetailActionsDiv = document.getElementById('item-detail-actions');
        const equipButton = document.getElementById('equip-button');
        const discardButton = document.getElementById('discard-button');


        // --- Game State & Configuration ---
        const MAX_BACKPACK_SIZE = 12;
        const MESSAGE_LIMIT = 50; // Increased message limit
        const FLEE_CHANCE = 0.33; const ITEM_DROP_CHANCE = 0.25; const TIER_LEVELS = { low: 5, mid: 11 };
        const BASE_DODGE_CHANCE = 0.05; const DODGE_PER_LEVEL = 0.005; const MAX_DODGE_CHANCE = 0.50;
        const EVASION_DODGE_BONUS = 0.30; const EVASION_DURATION = 3; const EVASION_COOLDOWN = 6; const EVASION_MAX_CAP = 0.85;
        const FIRST_AID_HEAL_PERCENT = 0.25; const FIRST_AID_COOLDOWN = 4;
        const MULTI_HIT_DAMAGE_MULTIPLIER = 0.95;
        const HORIZONTAL_ARC_LEVEL = 4; const HORIZONTAL_ARC_HITS = 2; const HORIZONTAL_ARC_COOLDOWN = 3;
        const HORIZONTAL_SQUARE_LEVEL = 7; const HORIZONTAL_SQUARE_HITS = 4; const HORIZONTAL_SQUARE_COOLDOWN = 5;
        const DEADLY_SINS_LEVEL = 11; const DEADLY_SINS_HITS = 7; const DEADLY_SINS_COOLDOWN = 13;
        const VORPAL_STRIKE_LEVEL = 16; const VORPAL_STRIKE_COOLDOWN = 12; const VORPAL_STRIKE_STUN_DURATION = 2; const VORPAL_STRIKE_BLEED_PERCENT = 0.08;
        const ENEMY_HP_SCALE_PER_LEVEL = 0.15; const ENEMY_STR_SCALE_PER_LEVEL = 1; const ENEMY_DEF_SCALE_PER_LEVEL = 0.5;
        const ENEMY_XP_SCALE_PER_LEVEL = 0.12;
        const HORNET_VENOM_CHANCE = 0.25; const HORNET_VENOM_DAMAGE = 5; const HORNET_VENOM_DURATION = 2;
        const KOBOLD_EVASION_CHANCE = 0.15; const KOBOLD_EVASION_DURATION = 1; const BOAR_CHARGE_CHANCE = 0.20; const BOAR_CHARGE_BONUS = 0.25;
        const INITIAL_CHAMPION_SPAWN_CHANCE = 0.20;
        const SUBSEQUENT_CHAMPION_SPAWN_CHANCE = 0.05;
        const CHAMPION_MIN_LEVEL_SPAWN = 10;
        const DEBUFF_DURATION = 3;
        const DEFENSE_DOWN_PERCENT = 0.30;
        const ATTACK_DOWN_PERCENT = 0.30;
        const STUN_DURATION = 1;
        const GOD_CHARGE_CHANCE = 0.15; const GOD_CHARGE_BONUS = 0.40; const GOD_GORE_CHANCE = 0.20;
        const ALPHA_POUNCE_CHANCE = 0.15; const WEAKENING_HOWL_CHANCE = 0.15;
        const ALPHA_DIRE_WOLF_DODGE_BONUS = 0.02;
        const XP_LEVEL_MULTIPLIER = 1.30;
        const ITEM_STAT_VARIATION_PERCENT = 0.15;
        const BURN_CHANCE = 0.25; const BURN_DAMAGE = 8; const BURN_DURATION = 2; const BURN_COOLDOWN = 5;
        const METAL_SLIME_BASE_FLEE_CHANCE = 0.05;
        const DISEASE_CHANCE = 0.30; const DISEASE_ATK_MULT = 0.75; const DISEASE_DEF_MULT = 0.75;
        const ACCESSORY_2ND_STAT_CHANCE = 0.20;
        const ACCESSORY_3RD_STAT_CHANCE = 0.05;
        const CRITICAL_HIT_CHANCE = 0.05; // Base crit chance
        const CRITICAL_HIT_MULTIPLIER = 1.5; // Base crit damage multiplier

        // Initial player state template including backpack and new stats
        const INITIAL_PLAYER_STATE = {
            hp: 100, maxHp: 100, str: 5, def: 4,
            dodgeChance: BASE_DODGE_CHANCE, evasionActive: false, evasionDuration: 0,
            poisonTurnsLeft: 0, bleedTurnsLeft: 0, bleedDamagePerTurn: 0, stunTurnsLeft: 0,
            defenseDownTurns: 0, defenseDownMultiplier: 1, attackDownTurns: 0, attackDownMultiplier: 1,
            burnTurnsLeft: 0, burnDamagePerTurn: 0, isDiseased: false,
            minDamage: 7, maxDamage: 12,
            critChance: CRITICAL_HIT_CHANCE,
            critDamageMultiplier: CRITICAL_HIT_MULTIPLIER,
            level: 1, xp: 0, xpToNextLevel: 80,
            equipment: { weapon: null, armor: null, accessory: null },
            backpack: []
        };

        const GOBLIN_BASE_DODGE = 0.08; const KOBOLD_BASE_DODGE = 0.06; const HORNET_BASE_DODGE = 0.12; const SLIME_BASE_DODGE = 0.03;

        // Enemy Catalog (unchanged)
        const enemyCatalog = [
             { name: "Wild Boar", hp: 55, str: 4, def: 2, minDamage: 3, maxDamage: 6, xpValue: 15, dodgeChance: 0.05, tier: 'low', minLevel: 1, imageSrc: 'Images/boar.jpg' },
             { name: "Hornet", hp: 30, str: 3, def: 0, minDamage: 1, maxDamage: 3, xpValue: 14, dodgeChance: HORNET_BASE_DODGE, tier: 'low', minLevel: 1, imageSrc: 'Images/hornet.jpg' },
             { name: "Kobold", hp: 45, str: 4, def: 1, minDamage: 2, maxDamage: 5, xpValue: 18, dodgeChance: KOBOLD_BASE_DODGE, tier: 'low', minLevel: 1, imageSrc: 'Images/kobold.png' },
             { name: "Slime", hp: 40, str: 2, def: 3, minDamage: 1, maxDamage: 2, xpValue: 10, dodgeChance: SLIME_BASE_DODGE, tier: 'low', minLevel: 1, imageSrc: 'Images/slime.jpg' },
             { name: "Little Nepenthes", hp: 35, str: 3, def: 1, minDamage: 2, maxDamage: 4, xpValue: 12, dodgeChance: 0.08, tier: 'low', minLevel: 1, imageSrc: 'Images/Little_Nepenthes.jpg' },
             { name: "Orc", hp: 90, str: 7, def: 3, minDamage: 5, maxDamage: 9, xpValue: 30, dodgeChance: 0.04, tier: 'mid', minLevel: TIER_LEVELS.low + 1, imageSrc: 'Images/orc.jpg' },
             { name: "Fire Dancer", hp: 100, str: 9, def: 4, minDamage: 7, maxDamage: 12, xpValue: 45, dodgeChance: 0.15, tier: 'mid', minLevel: 6, imageSrc: 'Images/firedancer.jpg' },
             { name: "Metal Slime", hp: 20, str: 8, def: 50, minDamage: 5, maxDamage: 10, xpValue: 200, dodgeChance: 0.05, tier: 'mid', minLevel: 7, imageSrc: 'Images/metalslime.jpg' },
             { name: "Infected Zombie", hp: 130, str: 7, def: 6, minDamage: 6, maxDamage: 11, xpValue: 55, dodgeChance: 0.02, tier: 'mid', minLevel: 6, imageSrc: 'Images/infected_zombie.jpg' },
             { name: "Dire Wolf", hp: 120, str: 8, def: 5, minDamage: 8, maxDamage: 15, xpValue: 50, dodgeChance: 0.10, tier: 'mid', minLevel: TIER_LEVELS.low + 1, imageSrc: 'Images/dire_wolf.jpg' },
             { name: "Ogre", hp: 250, str: 15, def: 8, minDamage: 15, maxDamage: 25, xpValue: 150, dodgeChance: 0.03, tier: 'high', minLevel: TIER_LEVELS.mid + 1, imageSrc: 'Images/ogre.jpg' },
             { name: "Boar God", hp: 600, str: 28, def: 18, minDamage: 28, maxDamage: 45, xpValue: 750, dodgeChance: 0.08, tier: 'champion', minLevel: CHAMPION_MIN_LEVEL_SPAWN, imageSrc: 'Images/boar_god.jpg' },
             { name: "Alpha Dire Wolf", hp: 450, str: 25, def: 15, minDamage: 25, maxDamage: 40, xpValue: 650, dodgeChance: 0.15 + ALPHA_DIRE_WOLF_DODGE_BONUS, tier: 'champion', minLevel: CHAMPION_MIN_LEVEL_SPAWN, imageSrc: 'Images/alpha_dire_wolf.jpg' },
        ];
        // Accessory naming (unchanged)
        const accessoryPrefixes = ["Simple", "Worn", "Engraved", "Ornate", "Glowing", "Ancient", "Blessed", "Cursed"];
        const accessoryTypes = ["Ring", "Amulet", "Charm", "Brooch", "Band", "Circlet", "Pendant"];
        // Equipment Catalog (unchanged)
        const equipmentCatalog = {
            weapon: [ { id: 'w_low_01', name: "Short Sword", category: 'weapon', tier: 'low', stats: { str: 1, minDmg: 1, maxDmg: 2 } }, { id: 'w_mid_01', name: "Long Sword", category: 'weapon', tier: 'mid', stats: { str: 3, minDmg: 3, maxDmg: 5 } }, { id: 'w_high_01', name: "Great Sword", category: 'weapon', tier: 'high', stats: { str: 6, minDmg: 6, maxDmg: 10 } }, ],
            armor: [ { id: 'a_low_01', name: "Leather Jerkin", category: 'armor', tier: 'low', stats: { def: 2, maxHp: 5 } }, { id: 'a_mid_01', name: "Chain Mail", category: 'armor', tier: 'mid', stats: { def: 5, maxHp: 15 } }, { id: 'a_high_01', name: "Plate Armor", category: 'armor', tier: 'high', stats: { def: 10, maxHp: 30 } }, ],
            accessory: [ { id: 'ac_low_01', baseName: "Ring", category: 'accessory', tier: 'low', stats: { maxHp: 5 } }, { id: 'ac_low_02', baseName: "Charm", category: 'accessory', tier: 'low', stats: { str: 1 } }, { id: 'ac_mid_01', baseName: "Amulet", category: 'accessory', tier: 'mid', stats: { def: 2, maxHp: 10 } }, { id: 'ac_mid_02', baseName: "Brooch", category: 'accessory', tier: 'mid', stats: { str: 1, def: 1 } }, { id: 'ac_high_01', baseName: "Pendant", category: 'accessory', tier: 'high', stats: { maxHp: 25, str: 2 } }, { id: 'ac_high_02', baseName: "Circlet", category: 'accessory', tier: 'high', stats: { dodge: 0.02, def: 3 } }, ]
        };
        const SECONDARY_ACCESSORY_STATS = { maxHp: 3, str: 1, def: 1, dodge: 0.01 };

        // --- Game State Variables ---
        let player = {};
        let enemy = {};
        let highScore = 0;
        let firstAidCooldownCounter = 0; let evasionCooldownCounter = 0; let horizontalArcCooldownCounter = 0; let horizontalSquareCooldownCounter = 0; let deadlySinsCooldownCounter = 0;
        let selectedPlayerImage = 'Images/they_them.jpg';
        let currentChampionSpawnChance = INITIAL_CHAMPION_SPAWN_CHANCE;
        let wasAfterCombat = false;
        let selectedBackpackIndex = -1;

        // Skill Tooltips (unchanged)
        const skillTooltips = {
            'horizontal-button': { name: 'Horizontal Strike', level: 1, desc: 'A basic horizontal sword slash.', effect: 'Deals physical damage based on STR and weapon stats, reduced by enemy DEF.', cost: 'Action', cooldown: 0 },
            'horizontal-arc-button': { name: 'Horizontal Arc', level: HORIZONTAL_ARC_LEVEL, desc: 'A wider slash hitting multiple times.', effect: `Deals ${HORIZONTAL_ARC_HITS} hits at ${MULTI_HIT_DAMAGE_MULTIPLIER*100}% damage each.`, cost: 'Action', cooldown: HORIZONTAL_ARC_COOLDOWN },
            'horizontal-square-button': { name: 'Horizontal Square', level: HORIZONTAL_SQUARE_LEVEL, desc: 'A rapid four-hit combo.', effect: `Deals ${HORIZONTAL_SQUARE_HITS} hits at ${MULTI_HIT_DAMAGE_MULTIPLIER*100}% damage each.`, cost: 'Action', cooldown: HORIZONTAL_SQUARE_COOLDOWN },
            'deadly-sins-button': { name: 'Deadly Sins', level: DEADLY_SINS_LEVEL, desc: 'A devastating seven-hit sword skill.', effect: `Deals ${DEADLY_SINS_HITS} hits at ${MULTI_HIT_DAMAGE_MULTIPLIER*100}% damage each.`, cost: 'Action', cooldown: DEADLY_SINS_COOLDOWN },
            'evasion-button': { name: 'Evasion', level: 1, desc: 'Temporarily increases dodge chance.', effect: `Increases Dodge Chance by ${EVASION_DODGE_BONUS*100}% for ${EVASION_DURATION} turns (max ${EVASION_MAX_CAP*100}%).`, cost: 'Instant', cooldown: EVASION_COOLDOWN },
            'first-aid-button': { name: 'First Aid', level: 1, desc: 'Heals a portion of maximum HP.', effect: `Restores ${FIRST_AID_HEAL_PERCENT*100}% of Max HP.`, cost: 'Instant', cooldown: FIRST_AID_COOLDOWN },
            'flee-button': { name: 'Flee', level: 1, desc: 'Attempt to escape from a powerful foe.', effect: `Allows escape from Champions with a ${FLEE_CHANCE*100}% chance. Fails otherwise.`, cost: 'Action', cooldown: 0 },
        };

        // --- Screen Transition Functions (unchanged) ---
        function showStartScreen() { startScreen.classList.add('active'); gameScreen.classList.remove('active'); console.log("Showing Start Screen"); }
        function showGameScreen() { startScreen.classList.remove('active'); gameScreen.classList.add('active'); console.log("Showing Game Screen"); }

        // --- Helper Functions (unchanged) ---
        function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; }
        function randomizeStat(baseValue, variationPercent) { if (baseValue === 0) return 0; const variation = baseValue * variationPercent; const randomVariation = (Math.random() * variation * 2) - variation; let randomizedValue = baseValue + randomVariation; if (Number.isInteger(baseValue)) { randomizedValue = Math.max(1, Math.round(randomizedValue)); } else { randomizedValue = Math.max(0, parseFloat(randomizedValue.toFixed(3))); } return randomizedValue; }
        function randomizeItemStats(baseStats, category) { const randomizedStats = {}; const existingStatKeys = []; for (const statKey in baseStats) { if (baseStats.hasOwnProperty(statKey)) { existingStatKeys.push(statKey); randomizedStats[statKey] = randomizeStat(baseStats[statKey], ITEM_STAT_VARIATION_PERCENT); } } if (category === 'accessory') { const possibleExtraStats = Object.keys(SECONDARY_ACCESSORY_STATS); if (Math.random() < ACCESSORY_2ND_STAT_CHANCE) { let availableStats = possibleExtraStats.filter(stat => !existingStatKeys.includes(stat)); if (availableStats.length > 0) { const chosenStatKey = availableStats[getRandomInt(0, availableStats.length - 1)]; const baseValue = SECONDARY_ACCESSORY_STATS[chosenStatKey]; randomizedStats[chosenStatKey] = randomizeStat(baseValue, ITEM_STAT_VARIATION_PERCENT); existingStatKeys.push(chosenStatKey); console.log(`Accessory rolled 2nd stat: ${chosenStatKey}`); if (Math.random() < ACCESSORY_3RD_STAT_CHANCE) { availableStats = possibleExtraStats.filter(stat => !existingStatKeys.includes(stat)); if (availableStats.length > 0) { const chosenStatKey3 = availableStats[getRandomInt(0, availableStats.length - 1)]; const baseValue3 = SECONDARY_ACCESSORY_STATS[chosenStatKey3]; randomizedStats[chosenStatKey3] = randomizeStat(baseValue3, ITEM_STAT_VARIATION_PERCENT); console.log(`Accessory rolled 3rd stat: ${chosenStatKey3}`); } } } } } return randomizedStats; }
        function randomizeStatsHigh(baseStats) { const randomizedStats = {}; for (const statKey in baseStats) { if (baseStats.hasOwnProperty(statKey)) { const baseValue = baseStats[statKey]; if (baseValue === 0) { randomizedStats[statKey] = 0; continue; } const variation = baseValue * ITEM_STAT_VARIATION_PERCENT; const randomVariation = Math.random() * variation; let randomizedValue = baseValue + randomVariation; if (Number.isInteger(baseValue)) { randomizedStats[statKey] = Math.max(1, Math.round(randomizedValue)); } else { randomizedStats[statKey] = Math.max(0, parseFloat(randomizedValue.toFixed(3))); } } } return randomizedStats; }
        function getBaseItemDataById(itemId) { for (const category in equipmentCatalog) { if (equipmentCatalog.hasOwnProperty(category) && Array.isArray(equipmentCatalog[category])) { const item = equipmentCatalog[category].find(i => i && i.id === itemId); if (item) return item; } else { console.warn(`Equipment category '${category}' is missing or not an array.`); } } console.warn(`Base Item data not found for ID: ${itemId}`); return null; }
        function generateAccessoryName(baseName) { const prefix = accessoryPrefixes[getRandomInt(0, accessoryPrefixes.length - 1)]; return `${prefix} ${baseName}`; }
        function formatStatName(key) { switch (key) { case 'maxHp': return 'Max HP'; case 'str': return 'STR'; case 'def': return 'DEF'; case 'minDmg': return 'Min DMG'; case 'maxDmg': return 'Max DMG'; case 'dodge': return 'Dodge'; case 'critChance': return 'Crit Chance'; case 'critDamageMultiplier': return 'Crit Damage'; default: return key.toUpperCase(); } }

        // --- Core Game Logic ---
        // Calculate player's total stats including base stats, equipment, and temporary effects
        function calculateTotalStats() {
            // Ensure base stats are initialized
            player.baseMaxHp = player.baseMaxHp ?? INITIAL_PLAYER_STATE.maxHp;
            player.baseStr = player.baseStr ?? INITIAL_PLAYER_STATE.str;
            player.baseDef = player.baseDef ?? INITIAL_PLAYER_STATE.def;
            player.baseMinDmg = player.baseMinDmg ?? INITIAL_PLAYER_STATE.minDamage;
            player.baseMaxDmg = player.baseMaxDmg ?? INITIAL_PLAYER_STATE.maxDamage;
            player.baseCritChance = player.baseCritChance ?? INITIAL_PLAYER_STATE.critChance;
            player.baseCritDamageMultiplier = player.baseCritDamageMultiplier ?? INITIAL_PLAYER_STATE.critDamageMultiplier;

            // Reset current stats to base stats
            player.maxHp = player.baseMaxHp;
            player.str = player.baseStr;
            player.def = player.baseDef;
            player.minDamage = player.baseMinDmg;
            player.maxDamage = player.baseMaxDmg;
            player.critChance = player.baseCritChance;
            player.critDamageMultiplier = player.baseCritDamageMultiplier;

            // Apply equipment stats
            let dodgeBonusFromEquipment = 0;
            for (const slot in player.equipment) {
                const equippedItem = player.equipment[slot];
                if (equippedItem && equippedItem.stats) {
                    const itemStats = equippedItem.stats;
                    player.maxHp += itemStats.maxHp || 0;
                    player.str += itemStats.str || 0;
                    player.def += itemStats.def || 0;
                    player.minDamage += itemStats.minDmg || 0;
                    player.maxDamage += itemStats.maxDmg || 0;
                    dodgeBonusFromEquipment += itemStats.dodge || 0;
                    player.critChance += itemStats.critChance || 0;
                    player.critDamageMultiplier += itemStats.critDamageMultiplier || 0;
                }
            }

            // Apply permanent Disease debuff
            if (player.isDiseased) {
                player.str = Math.max(0, Math.floor(player.str * DISEASE_ATK_MULT));
                player.def = Math.max(0, Math.floor(player.def * DISEASE_DEF_MULT));
            }

            // Apply temporary debuffs
            if (player.attackDownTurns > 0) { player.str = Math.max(0, Math.floor(player.str * player.attackDownMultiplier)); }
            if (player.defenseDownTurns > 0) { player.def = Math.max(0, Math.floor(player.def * player.defenseDownMultiplier)); }

            // Calculate final dodge chance
            let levelDodgeBonus = DODGE_PER_LEVEL * (player.level - 1);
            player.dodgeChance = Math.min(BASE_DODGE_CHANCE + levelDodgeBonus + dodgeBonusFromEquipment, MAX_DODGE_CHANCE);

            // Apply Evasion buff
            if (player.evasionActive) { player.dodgeChance = Math.min(player.dodgeChance + EVASION_DODGE_BONUS, EVASION_MAX_CAP); }

            // Ensure HP doesn't exceed max
            player.hp = Math.min(player.hp, player.maxHp);
        }

        // New function to match only player and enemy heights
        function adjustPlayerEnemyHeight() {
            // Reset heights first to get natural height
            playerStatsBlock.style.minHeight = 'auto';
            enemyStatsBlock.style.minHeight = 'auto';

            // Use setTimeout to allow browser rendering before getting height
            setTimeout(() => {
                const playerHeight = playerStatsBlock.offsetHeight;
                const enemyHeight = enemyStatsBlock.offsetHeight;
                const maxHeight = Math.max(playerHeight, enemyHeight);

                // Only set min-height if blocks exist
                if (playerStatsBlock) playerStatsBlock.style.minHeight = `${maxHeight}px`;
                if (enemyStatsBlock) enemyStatsBlock.style.minHeight = `${maxHeight}px`;
            }, 0);
        }


        // Update the player's stats display on the screen
        function updatePlayerStatDisplay() {
            if (!player || typeof player.hp === 'undefined') { console.error("Player data missing for display."); return; }
            playerImageElement.src = selectedPlayerImage;
            playerLevelElement.textContent = player.level;
            playerXpElement.textContent = player.xp;
            playerXpNeededElement.textContent = player.xpToNextLevel;
            playerHpElement.textContent = Math.max(0, player.hp);
            playerMaxHpElement.textContent = player.maxHp;
            playerStrElement.textContent = player.str;
            playerDefElement.textContent = player.def;
            playerDodgeElement.textContent = (player.dodgeChance * 100).toFixed(1);
            playerCritChanceElement.textContent = (player.critChance * 100).toFixed(1);
            playerCritDamageElement.textContent = Math.round(player.critDamageMultiplier * 100);
            playerMinDmgElement.textContent = player.minDamage;
            playerMaxDmgElement.textContent = player.maxDamage;
            currentLevelValueElement.textContent = player.level;

            let debuffText = "";
            if (player.stunTurnsLeft > 0) debuffText += "[Stunned] ";
            if (player.poisonTurnsLeft > 0) debuffText += "[Poisoned] ";
            if (player.burnTurnsLeft > 0) debuffText += "[Burning] ";
            if (player.attackDownTurns > 0) debuffText += "[ATK Down] ";
            if (player.defenseDownTurns > 0) debuffText += "[DEF Down] ";
            if (player.isDiseased) debuffText += "[Diseased] ";
            playerDebuffIndicator.textContent = debuffText.trim();

            updateSkillButtons();
            updateEquippedDisplay(); // Update simple display
            displayInventory(); // Update the integrated inventory display
            adjustPlayerEnemyHeight(); // Adjust height after updates
        }

        // Update the enemy's stats display (simplified)
        function updateEnemyStatDisplay() {
             if (!enemy || typeof enemy.hp === 'undefined') {
                 enemyNameElement.textContent = "---";
                 enemyHpElement.textContent = "---";
                 enemyMaxHpElement.textContent = "---";
                 enemyStrElement.textContent = "---";
                 enemyDefElement.textContent = "---";
                 enemyDodgeElement.textContent = "---";
                 enemyImageElement.src = 'https://placehold.co/80x80/2c3e50/ecf0f1?text=Defeated';
                 enemyImageElement.alt = "No Enemy";
                 if (enemyDebuffIndicator) enemyDebuffIndicator.textContent = "";
                 adjustPlayerEnemyHeight(); // Adjust height even when empty
                 return;
             }
             enemyNameElement.textContent = enemy.name || "Unknown";
             enemyHpElement.textContent = Math.max(0, enemy.hp);
             enemyMaxHpElement.textContent = enemy.maxHp;
             enemyStrElement.textContent = enemy.str;
             enemyDefElement.textContent = enemy.def;
             enemyDodgeElement.textContent = (enemy.dodgeChance * 100).toFixed(1);
             enemyImageElement.src = enemy.imageSrc || 'https://placehold.co/80x80/2c3e50/ecf0f1?text=Enemy';
             enemyImageElement.alt = (enemy.name || "Enemy") + " Character";

             let debuffText = "";
             if (enemy.evasionActive) debuffText += "[Evasive] ";
             if (enemyDebuffIndicator) enemyDebuffIndicator.textContent = debuffText.trim();

             adjustPlayerEnemyHeight(); // Adjust height after updates
        }
        // Update the simple equipment display row (unchanged)
        function updateEquippedDisplay() { if (!player || !player.equipment) { console.error("Player equipment data missing."); return; } const weaponItem = player.equipment.weapon; const armorItem = player.equipment.armor; const accessoryItem = player.equipment.accessory; const getItemDisplay = (item) => { if (!item) return { name: "None", className: "" }; const name = item.name || item.baseName || "Unknown"; const tierClass = `item-tier-${item.tier || 'low'}`; return { name: name, className: tierClass }; }; const weaponDisplay = getItemDisplay(weaponItem); equippedWeaponElement.innerHTML = `<span class="${weaponDisplay.className}">${weaponDisplay.name}</span>`; const armorDisplay = getItemDisplay(armorItem); equippedArmorElement.innerHTML = `<span class="${armorDisplay.className}">${armorDisplay.name}</span>`; const accessoryDisplay = getItemDisplay(accessoryItem); equippedAccessoryElement.innerHTML = `<span class="${accessoryDisplay.className}">${accessoryDisplay.name}</span>`; }

        // Log message function (unchanged)
        function logMessage(newMessage) { const messageContainer = document.getElementById('message'); if (!messageContainer) return; const wasScrolledToBottom = messageContainer.scrollHeight - messageContainer.clientHeight <= messageContainer.scrollTop + 1; const p = document.createElement('p'); p.innerHTML = newMessage; messageContainer.appendChild(p); while (messageContainer.children.length > MESSAGE_LIMIT) { messageContainer.removeChild(messageContainer.firstChild); } if (wasScrolledToBottom) { messageContainer.scrollTop = messageContainer.scrollHeight; } }
        // Spawn enemy function (unchanged)
        function spawnEnemy() { let possibleEnemies = []; let spawnChampion = false; const playerLevelNum = Number(player.level) || 1; if (playerLevelNum >= CHAMPION_MIN_LEVEL_SPAWN && Math.random() < currentChampionSpawnChance) { const championEnemies = enemyCatalog.filter(e => e && e.tier === 'champion' && e.minLevel <= playerLevelNum); if (championEnemies.length > 0) { possibleEnemies = championEnemies; spawnChampion = true; console.log(`Champion spawn triggered (Chance: ${currentChampionSpawnChance*100}%). Possible: ${possibleEnemies.map(e=>e.name).join(', ')}`); currentChampionSpawnChance = SUBSEQUENT_CHAMPION_SPAWN_CHANCE; console.log(`Champion spawn chance reduced to ${currentChampionSpawnChance*100}%`); } else { console.warn("Champion spawn triggered, but no suitable champions found."); } } if (!spawnChampion) { let currentTier = 'low'; if (playerLevelNum > TIER_LEVELS.mid) { currentTier = 'high'; } else if (playerLevelNum > TIER_LEVELS.low) { currentTier = 'mid'; } console.log(`Player level ${playerLevelNum}, targeting tier: ${currentTier}`); possibleEnemies = enemyCatalog.filter(e => e && e.tier === currentTier && e.minLevel <= playerLevelNum); if (possibleEnemies.length === 0 && currentTier === 'high') { console.log(`No high tier enemies, trying mid tier...`); currentTier = 'mid'; possibleEnemies = enemyCatalog.filter(e => e && e.tier === currentTier && e.minLevel <= playerLevelNum); } if (possibleEnemies.length === 0 && currentTier === 'mid') { console.log(`No mid tier enemies, trying low tier...`); currentTier = 'low'; possibleEnemies = enemyCatalog.filter(e => e && e.tier === currentTier && e.minLevel <= playerLevelNum); } if (possibleEnemies.length === 0) { console.error(`ERROR: No suitable regular enemies found for player level ${playerLevelNum}!`); logMessage("<span style='color:red;'>Error: No enemies available to spawn!</span>"); horizontalButton.disabled = true; updateSkillButtons(); return; } console.log(`Possible regular enemies (Tier: ${currentTier}): ${possibleEnemies.map(e=>e.name).join(', ')}`); } const randomIndex = getRandomInt(0, possibleEnemies.length - 1); const baseEnemy = possibleEnemies[randomIndex]; if (!baseEnemy) { console.error(`ERROR: Failed to get baseEnemy (Index: ${randomIndex}).`); logMessage("<span style='color:red;'>Error: Could not select an enemy!</span>"); return; } console.log(`Spawning: ${baseEnemy.name} (Tier: ${baseEnemy.tier})`); enemy = { ...baseEnemy }; enemy.fireDancerBurnCooldown = 0; enemy.metalSlimeFleeAttempts = 0; let levelForScaling = playerLevelNum; if (enemy.tier === 'champion') { enemy.spawnedAtPlayerLevel = playerLevelNum; levelForScaling = enemy.spawnedAtPlayerLevel; } const playerLevelFactor = Math.max(0, levelForScaling - 1); const baseHp = Number(baseEnemy.hp) || 50; const baseStr = Number(baseEnemy.str) || 1; const baseDef = Number(baseEnemy.def) || 0; const baseXp = Number(baseEnemy.xpValue) || 10; enemy.hp = Math.max(1, Math.floor(baseHp * (1 + (ENEMY_HP_SCALE_PER_LEVEL * playerLevelFactor)))); enemy.maxHp = enemy.hp; enemy.str = Math.floor(baseStr + (ENEMY_STR_SCALE_PER_LEVEL * playerLevelFactor)); enemy.def = Math.floor(baseDef + (ENEMY_DEF_SCALE_PER_LEVEL * playerLevelFactor)); enemy.xpValue = Math.floor(baseXp * (1 + (ENEMY_XP_SCALE_PER_LEVEL * playerLevelFactor))); enemy.dodgeChance = Number(baseEnemy.dodgeChance) || BASE_DODGE_CHANCE; enemy.minDamage = Number(baseEnemy.minDamage) || 1; enemy.maxDamage = Number(baseEnemy.maxDamage) || 2; console.log(`Scaled Stats (Lvl ${levelForScaling}): HP=${enemy.hp}/${enemy.maxHp}, STR=${enemy.str}, DEF=${enemy.def}, XP=${enemy.xpValue}`); enemy.isCharging = false; enemy.isGodCharging = false; enemy.evasionActive = false; enemy.evasionDuration = 0; updateEnemyStatDisplay(); const announceLevel = enemy.tier === 'champion' ? levelForScaling : playerLevelNum; if (enemy.tier === 'champion') { logMessage(`<span style='color: red; font-weight: bold;'>A powerful Level ${announceLevel} ${enemy.name} appears!</span>`); } else { logMessage(`A wild Level ${announceLevel} ${enemy.name} appears!`); } if (fleeButton) { fleeButton.classList.toggle('hidden', enemy.tier !== 'champion'); fleeButton.disabled = (enemy.tier !== 'champion'); } horizontalButton.disabled = false; updateSkillButtons(); }
        // Decrement cooldowns function (unchanged)
        function decrementCooldowns() { if (evasionCooldownCounter > 0) { evasionCooldownCounter--; evasionButton.textContent = `Evasion (${evasionCooldownCounter})`; if (evasionCooldownCounter <= 0) { evasionButton.disabled = false; evasionButton.textContent = "Evasion"; logMessage("<span style='color:cyan;'>Evasion ready!</span>"); } } if (firstAidCooldownCounter > 0) { firstAidCooldownCounter--; firstAidButton.textContent = `First Aid (${firstAidCooldownCounter})`; if (firstAidCooldownCounter <= 0) { firstAidButton.disabled = false; firstAidButton.textContent = "First Aid"; logMessage("<span style='color:lightgreen;'>First Aid ready!</span>"); } } if (horizontalArcCooldownCounter > 0) { horizontalArcCooldownCounter--; horizontalArcButton.textContent = `H. Arc (${horizontalArcCooldownCounter})`; if (horizontalArcCooldownCounter <= 0) { horizontalArcButton.disabled = player.level < HORIZONTAL_ARC_LEVEL; horizontalArcButton.textContent = "Horizontal Arc"; if (!horizontalArcButton.disabled) logMessage("<span style='color:lightblue;'>Horizontal Arc ready!</span>"); } } if (horizontalSquareCooldownCounter > 0) { horizontalSquareCooldownCounter--; horizontalSquareButton.textContent = `H. Square (${horizontalSquareCooldownCounter})`; if (horizontalSquareCooldownCounter <= 0) { horizontalSquareButton.disabled = player.level < HORIZONTAL_SQUARE_LEVEL; horizontalSquareButton.textContent = "Horizontal Square"; if (!horizontalSquareButton.disabled) logMessage("<span style='color:lightblue;'>Horizontal Square ready!</span>"); } } if (deadlySinsCooldownCounter > 0) { deadlySinsCooldownCounter--; deadlySinsButton.textContent = `D. Sins (${deadlySinsCooldownCounter})`; if (deadlySinsCooldownCounter <= 0) { deadlySinsButton.disabled = player.level < DEADLY_SINS_LEVEL; deadlySinsButton.textContent = "Deadly Sins"; if (!deadlySinsButton.disabled) logMessage("<span style='color:violet;'>Deadly Sins ready!</span>"); } } if (enemy && enemy.name === "Fire Dancer" && enemy.fireDancerBurnCooldown > 0) { enemy.fireDancerBurnCooldown--; } }
        // Apply player status effects function (unchanged)
        function applyPlayerStatusEffects() { let stillAlive = true; if (stillAlive && player.burnTurnsLeft > 0) { const burnDmg = player.burnDamagePerTurn; player.hp = Math.max(0, player.hp - burnDmg); player.burnTurnsLeft--; logMessage(`<span class="special-message burn-message">Burning! Took ${burnDmg} damage (${player.burnTurnsLeft} turns left)</span>`); updatePlayerStatDisplay(); if (player.hp <= 0) { logMessage("<span style='color:red; font-weight:bold;'>Succumbed to burns! GAME OVER.</span>"); if (player.level > highScore) { highScore = player.level; saveHighScore(); updateHighScoreDisplay(); logMessage(`New highest level: ${highScore}!`); } horizontalButton.disabled = true; updateSkillButtons(); evasionButton.disabled = true; firstAidButton.disabled = true; if(fleeButton) fleeButton.disabled = true; stillAlive = false; } if (player.burnTurnsLeft <= 0) { player.burnDamagePerTurn = 0; logMessage("<span class='special-message debuff-faded-message'>The burning stopped.</span>"); } } if (stillAlive && player.poisonTurnsLeft > 0) { const poisonDamage = HORNET_VENOM_DAMAGE; player.hp = Math.max(0, player.hp - poisonDamage); player.poisonTurnsLeft--; logMessage(`<span style="color:purple;">Venom deals ${poisonDamage} damage! (${player.poisonTurnsLeft} turns left)</span>`); updatePlayerStatDisplay(); if (player.hp <= 0) { logMessage("<span style='color:red; font-weight:bold;'>Succumbed to venom! GAME OVER.</span>"); if (player.level > highScore) { highScore = player.level; saveHighScore(); updateHighScoreDisplay(); logMessage(`New highest level: ${highScore}!`); } horizontalButton.disabled = true; updateSkillButtons(); evasionButton.disabled = true; firstAidButton.disabled = true; if(fleeButton) fleeButton.disabled = true; stillAlive = false; } } if (stillAlive && player.bleedTurnsLeft > 0) { const bleedDamage = player.bleedDamagePerTurn; player.hp = Math.max(0, player.hp - bleedDamage); player.bleedTurnsLeft--; logMessage(`<span style="color:red;">Bleeding deals ${bleedDamage} damage! (${player.bleedTurnsLeft} turns left)</span>`); updatePlayerStatDisplay(); if (player.hp <= 0) { logMessage("<span style='color:red; font-weight:bold;'>Bled out! GAME OVER.</span>"); if (player.level > highScore) { highScore = player.level; saveHighScore(); updateHighScoreDisplay(); logMessage(`New highest level: ${highScore}!`); } horizontalButton.disabled = true; updateSkillButtons(); evasionButton.disabled = true; firstAidButton.disabled = true; if(fleeButton) fleeButton.disabled = true; stillAlive = false; } if (player.bleedTurnsLeft <= 0) { player.bleedDamagePerTurn = 0; logMessage("Bleeding stops."); } } return stillAlive; }
        // Enemy turn logic (unchanged)
        function enemyTurn() { if (player.hp <= 0 || !enemy || enemy.hp <= 0) { console.log("Enemy turn skipped."); return; } console.log(`Enemy turn: ${enemy.name}`); let enemyActionTaken = false; let usedModifyingSkill = false; if (enemy.name === "Metal Slime") { enemy.metalSlimeFleeAttempts++; const currentFleeChance = METAL_SLIME_BASE_FLEE_CHANCE * enemy.metalSlimeFleeAttempts; console.log(`Metal Slime flee attempt ${enemy.metalSlimeFleeAttempts}, chance: ${currentFleeChance * 100}%`); if (Math.random() < currentFleeChance) { logMessage(`<span style='color:grey;'>The ${enemy.name} fled!</span>`); spawnEnemy(); return; } } if (enemy.tier === 'champion') { if (enemy.name === "Boar God") { if (player.defenseDownTurns <= 0 && Math.random() < GOD_GORE_CHANCE) { player.defenseDownTurns = DEBUFF_DURATION; player.defenseDownMultiplier = 1 - DEFENSE_DOWN_PERCENT; logMessage(`<span class="special-message debuff-applied-message">${enemy.name} uses God Gore! Your Defense is lowered!</span>`); calculateTotalStats(); updatePlayerStatDisplay(); enemyActionTaken = true; } else if (Math.random() < GOD_CHARGE_CHANCE && !enemy.isGodCharging) { enemy.isGodCharging = true; logMessage(`<span style='color:darkred; font-weight:bold;'>${enemy.name} lowers its tusks, preparing God Charge!</span>`); usedModifyingSkill = true; enemyActionTaken = true; } } else if (enemy.name === "Alpha Dire Wolf") { if (player.attackDownTurns <= 0 && Math.random() < WEAKENING_HOWL_CHANCE) { player.attackDownTurns = DEBUFF_DURATION; player.attackDownMultiplier = 1 - ATTACK_DOWN_PERCENT; logMessage(`<span class="special-message debuff-applied-message">${enemy.name} lets out a Weakening Howl! Your Attack is lowered!</span>`); calculateTotalStats(); updatePlayerStatDisplay(); enemyActionTaken = true; } else if (player.stunTurnsLeft <= 0 && Math.random() < ALPHA_POUNCE_CHANCE) { player.stunTurnsLeft = STUN_DURATION; logMessage(`<span style='color:orange; font-weight:bold;'>${enemy.name} uses Alpha Pounce! You are stunned!</span>`); enemyActionTaken = true; } } } if (!enemyActionTaken && enemy.tier !== 'champion') { if (enemy.name === "Hornet" && player.poisonTurnsLeft <= 0 && Math.random() < HORNET_VENOM_CHANCE) { player.poisonTurnsLeft = HORNET_VENOM_DURATION; logMessage(`<span style="color:purple;">${enemy.name} injects venom! You are poisoned!</span>`); enemyActionTaken = true; } else if (enemy.name === "Kobold" && Math.random() < KOBOLD_EVASION_CHANCE && !enemy.evasionActive) { enemy.evasionActive = true; enemy.evasionDuration = KOBOLD_EVASION_DURATION; logMessage(`<span style="color:teal;">${enemy.name} nimbly dodges, becoming evasive!</span>`); updateEnemyStatDisplay(); enemyActionTaken = true; } else if (enemy.name === "Wild Boar" && Math.random() < BOAR_CHARGE_CHANCE && !enemy.isCharging) { enemy.isCharging = true; logMessage(`<span style="color:red;">${enemy.name} paws the ground, preparing to charge!</span>`); usedModifyingSkill = true; enemyActionTaken = true; } else if (enemy.name === "Fire Dancer" && enemy.fireDancerBurnCooldown <= 0 && Math.random() < BURN_CHANCE) { if (player.burnTurnsLeft <= 0) { player.burnTurnsLeft = BURN_DURATION; player.burnDamagePerTurn = BURN_DAMAGE; logMessage(`<span class="special-message burn-message">${enemy.name} uses Fiery Dance! You are burned!</span>`); } else { player.burnTurnsLeft = BURN_DURATION; logMessage(`<span class="special-message burn-message">${enemy.name}'s Fiery Dance intensifies the burn!</span>`); } enemy.fireDancerBurnCooldown = BURN_COOLDOWN; enemyActionTaken = true; } } if (!enemyActionTaken) { console.log("Enemy performing standard attack."); const playerDodgeRoll = Math.random(); const currentP_Dodge = player.dodgeChance || 0; if (playerDodgeRoll < currentP_Dodge) { logMessage(`<span style='color: cyan;'>You dodged ${enemy.name}'s attack!</span>`); if (enemy.isCharging) { enemy.isCharging = false; logMessage(`${enemy.name}'s charge misses!`); } if (enemy.isGodCharging) { enemy.isGodCharging = false; logMessage(`${enemy.name}'s God Charge misses!`); } } else { let potentialEnemyDamage = getRandomInt(enemy.minDamage, enemy.maxDamage) + enemy.str; let attackMessage = `${enemy.name} attacks!`; let isCrit = false; if (Math.random() < CRITICAL_HIT_CHANCE) { potentialEnemyDamage = Math.floor(potentialEnemyDamage * CRITICAL_HIT_MULTIPLIER); isCrit = true; } if (enemy.isCharging) { potentialEnemyDamage = Math.floor(potentialEnemyDamage * (1 + BOAR_CHARGE_BONUS)); attackMessage = `${enemy.name}'s <span style='color:red;'>Charge</span> connects!`; enemy.isCharging = false; } else if (enemy.isGodCharging) { potentialEnemyDamage = Math.floor(potentialEnemyDamage * (1 + GOD_CHARGE_BONUS)); attackMessage = `${enemy.name}'s <span style='color:darkred; font-weight:bold;'>God Charge</span> slams into you!`; enemy.isGodCharging = false; } let finalEnemyDamage = Math.max(1, potentialEnemyDamage - player.def); player.hp = Math.max(0, player.hp - finalEnemyDamage); updatePlayerStatDisplay(); let damageLog = `${attackMessage} You take ${finalEnemyDamage} damage!`; if (isCrit) { damageLog = `${attackMessage} <span class='critical-hit'>Critical Hit!</span> You take ${finalEnemyDamage} damage!`; } logMessage(damageLog); if (enemy.name === "Infected Zombie" && !player.isDiseased && Math.random() < DISEASE_CHANCE) { player.isDiseased = true; logMessage(`<span class="special-message debuff-applied-message">You've been infected with Disease! Attack and Defense lowered!</span>`); calculateTotalStats(); updatePlayerStatDisplay(); } if (player.hp <= 0) { logMessage("<span style='color:red; font-weight:bold;'>Defeated! GAME OVER.</span>"); if (player.level > highScore) { highScore = player.level; saveHighScore(); updateHighScoreDisplay(); logMessage(`New highest level: ${highScore}!`); } horizontalButton.disabled = true; updateSkillButtons(); evasionButton.disabled = true; firstAidButton.disabled = true; if(fleeButton) fleeButton.disabled = true; return; } } } console.log("Enemy turn finished."); }
        // Handle player action taken function (unchanged)
        function handlePlayerActionTaken() { console.log("--- Post-Player Action ---"); let statsChanged = false; if (player.stunTurnsLeft > 0) { player.stunTurnsLeft--; if (player.stunTurnsLeft <= 0) { logMessage("You are no longer stunned."); statsChanged = true; } else { logMessage(`Still stunned for ${player.stunTurnsLeft} more turn(s).`); } } if (player.defenseDownTurns > 0) { player.defenseDownTurns--; if (player.defenseDownTurns <= 0) { player.defenseDownMultiplier = 1; logMessage("<span class='special-message debuff-faded-message'>Defense Down faded!</span>"); statsChanged = true; } } if (player.attackDownTurns > 0) { player.attackDownTurns--; if (player.attackDownTurns <= 0) { player.attackDownMultiplier = 1; logMessage("<span class='special-message debuff-faded-message'>Attack Down faded!</span>"); statsChanged = true; } } const playerSurvivedStatus = applyPlayerStatusEffects(); if (!playerSurvivedStatus) { console.log("Player died from status effects."); return; } if (player.evasionActive) { player.evasionDuration--; if (player.evasionDuration <= 0) { player.evasionActive = false; logMessage("Your heightened evasion wore off."); statsChanged = true; } } if (statsChanged) { calculateTotalStats(); updatePlayerStatDisplay(); } if (enemy && enemy.evasionActive) { enemy.evasionDuration--; if (enemy.evasionDuration <= 0) { enemy.evasionActive = false; enemy.evasionDuration = 0; logMessage(`${enemy.name} is no longer evasive.`); updateEnemyStatDisplay(); } } if (player.hp > 0 && enemy?.hp > 0) { decrementCooldowns(); console.log("Scheduling enemy turn..."); setTimeout(enemyTurn, 600); } else if (player.hp > 0 && (!enemy || enemy.hp <= 0)) { console.log("Enemy defeated, decrementing player cooldowns."); decrementCooldowns(); } console.log("--- End Post-Player Action ---"); }

        // --- Player Action Handlers (Combat - unchanged) ---
        function handleHorizontalClick() { if (player.stunTurnsLeft > 0) { logMessage("You are stunned!"); handlePlayerActionTaken(); return; } console.log("--- Horizontal Strike ---"); if (!enemy || enemy.hp <= 0) { logMessage("No enemy."); return; } if (enemy.evasionActive) { logMessage(`Attack misses! ${enemy.name} is evasive!`); handlePlayerActionTaken(); return; } if (Math.random() < enemy.dodgeChance) { logMessage(`<span style='color: orange;'>${enemy.name} dodged!</span>`); handlePlayerActionTaken(); return; } let damageDealt = Math.max(1, (getRandomInt(player.minDamage, player.maxDamage) + player.str) - enemy.def); let message = `You hit ${enemy.name} for`; let isCrit = false; if (Math.random() < player.critChance) { damageDealt = Math.floor(damageDealt * player.critDamageMultiplier); message += ` <span class='critical-hit'>Critical Hit!</span>`; isCrit = true; } enemy.hp = Math.max(0, enemy.hp - damageDealt); enemyHpElement.textContent = enemy.hp; logMessage(`${message} ${damageDealt} damage!`); if (enemy.hp <= 0) { handleEnemyDefeat(); } else { handlePlayerActionTaken(); } }
        function handleHorizontalArcClick() { if (player.stunTurnsLeft > 0) { logMessage("You are stunned!"); handlePlayerActionTaken(); return; } if (player.level < HORIZONTAL_ARC_LEVEL) { logMessage("Level not high enough!"); return; } if (horizontalArcCooldownCounter > 0) { logMessage(`On cooldown (${horizontalArcCooldownCounter} turns).`); return; } if (!enemy || enemy.hp <= 0) { logMessage("No enemy."); return; } console.log("--- Horizontal Arc ---"); logMessage("You use <span style='color:lightblue;'>Horizontal Arc</span>!"); let enemyDefeated = false; for (let i = 1; i <= HORIZONTAL_ARC_HITS && !enemyDefeated; i++) { if (enemy.evasionActive || Math.random() < enemy.dodgeChance) { logMessage(`&nbsp;&nbsp;<span style='color: orange;'>Hit ${i} missed!</span>`); continue; } let hitDamage = Math.max(1, Math.floor((getRandomInt(player.minDamage, player.maxDamage) * MULTI_HIT_DAMAGE_MULTIPLIER + player.str) - enemy.def)); let hitMessage = `&nbsp;&nbsp;Hit ${i} deals`; if (Math.random() < player.critChance) { hitDamage = Math.floor(hitDamage * player.critDamageMultiplier); hitMessage += ` <span class='critical-hit'>Critical Hit!</span>`; } enemy.hp = Math.max(0, enemy.hp - hitDamage); enemyHpElement.textContent = enemy.hp; logMessage(`${hitMessage} ${hitDamage} damage!`); if (enemy.hp <= 0) { enemyDefeated = true; } } horizontalArcCooldownCounter = HORIZONTAL_ARC_COOLDOWN; horizontalArcButton.disabled = true; horizontalArcButton.textContent = `H. Arc (${horizontalArcCooldownCounter})`; if (enemyDefeated) { handleEnemyDefeat(); } else { handlePlayerActionTaken(); } }
        function handleHorizontalSquareClick() { if (player.stunTurnsLeft > 0) { logMessage("You are stunned!"); handlePlayerActionTaken(); return; } if (player.level < HORIZONTAL_SQUARE_LEVEL) { logMessage("Level not high enough!"); return; } if (horizontalSquareCooldownCounter > 0) { logMessage(`On cooldown (${horizontalSquareCooldownCounter} turns).`); return; } if (!enemy || enemy.hp <= 0) { logMessage("No enemy."); return; } console.log("--- Horizontal Square ---"); logMessage("You use <span style='color:lightblue;'>Horizontal Square</span>!"); let enemyDefeated = false; for (let i = 1; i <= HORIZONTAL_SQUARE_HITS && !enemyDefeated; i++) { if (enemy.evasionActive || Math.random() < enemy.dodgeChance) { logMessage(`&nbsp;&nbsp;<span style='color: orange;'>Hit ${i} missed!</span>`); continue; } let hitDamage = Math.max(1, Math.floor((getRandomInt(player.minDamage, player.maxDamage) * MULTI_HIT_DAMAGE_MULTIPLIER + player.str) - enemy.def)); let hitMessage = `&nbsp;&nbsp;Hit ${i} deals`; if (Math.random() < player.critChance) { hitDamage = Math.floor(hitDamage * player.critDamageMultiplier); hitMessage += ` <span class='critical-hit'>Critical Hit!</span>`; } enemy.hp = Math.max(0, enemy.hp - hitDamage); enemyHpElement.textContent = enemy.hp; logMessage(`${hitMessage} ${hitDamage} damage!`); if (enemy.hp <= 0) { enemyDefeated = true; } } horizontalSquareCooldownCounter = HORIZONTAL_SQUARE_COOLDOWN; horizontalSquareButton.disabled = true; horizontalSquareButton.textContent = `H. Square (${horizontalSquareCooldownCounter})`; if (enemyDefeated) { handleEnemyDefeat(); } else { handlePlayerActionTaken(); } }
        function handleDeadlySinsClick() { if (player.stunTurnsLeft > 0) { logMessage("You are stunned!"); handlePlayerActionTaken(); return; } if (player.level < DEADLY_SINS_LEVEL) { logMessage("Level not high enough!"); return; } if (deadlySinsCooldownCounter > 0) { logMessage(`On cooldown (${deadlySinsCooldownCounter} turns).`); return; } if (!enemy || enemy.hp <= 0) { logMessage("No enemy."); return; } console.log("--- Deadly Sins ---"); logMessage("You unleash <span style='color:violet; font-weight:bold;'>Deadly Sins</span>!"); let enemyDefeated = false; for (let i = 1; i <= DEADLY_SINS_HITS && !enemyDefeated; i++) { if (enemy.evasionActive || Math.random() < enemy.dodgeChance) { logMessage(`&nbsp;&nbsp;<span style='color: orange;'>Hit ${i} missed!</span>`); continue; } let hitDamage = Math.max(1, Math.floor((getRandomInt(player.minDamage, player.maxDamage) * MULTI_HIT_DAMAGE_MULTIPLIER + player.str) - enemy.def)); let hitMessage = `&nbsp;&nbsp;Hit ${i} deals`; if (Math.random() < player.critChance) { hitDamage = Math.floor(hitDamage * player.critDamageMultiplier); hitMessage += ` <span class='critical-hit'>Critical Hit!</span>`; } enemy.hp = Math.max(0, enemy.hp - hitDamage); enemyHpElement.textContent = enemy.hp; logMessage(`${hitMessage} ${hitDamage} damage!`); if (enemy.hp <= 0) { enemyDefeated = true; } } deadlySinsCooldownCounter = DEADLY_SINS_COOLDOWN; deadlySinsButton.disabled = true; deadlySinsButton.textContent = `D. Sins (${deadlySinsCooldownCounter})`; if (enemyDefeated) { handleEnemyDefeat(); } else { handlePlayerActionTaken(); } }
        function handleEvasionClick() { if (player.stunTurnsLeft > 0) { logMessage("You are stunned!"); return; } console.log("--- Evasion (Instant) ---"); if (evasionCooldownCounter > 0) { logMessage(`On cooldown (${evasionCooldownCounter} turns).`); return; } if (player.evasionActive) { logMessage("Already active."); return; } player.evasionActive = true; player.evasionDuration = EVASION_DURATION; evasionCooldownCounter = EVASION_COOLDOWN; evasionButton.disabled = true; evasionButton.textContent = `Evasion (${evasionCooldownCounter})`; logMessage("<span style='color: cyan;'>You focus, becoming more evasive! (Instant)</span>"); calculateTotalStats(); updatePlayerStatDisplay(); }
        function handleFirstAidClick() { if (player.stunTurnsLeft > 0) { logMessage("You are stunned!"); return; } console.log("--- First Aid (Instant) ---"); if (firstAidCooldownCounter > 0) { logMessage(`On cooldown (${firstAidCooldownCounter} turns).`); return; } if (player.hp >= player.maxHp) { logMessage("Already full health."); return; } const healAmount = Math.floor(player.maxHp * FIRST_AID_HEAL_PERCENT); const oldHp = player.hp; player.hp = Math.min(player.maxHp, player.hp + healAmount); const actualHeal = player.hp - oldHp; firstAidCooldownCounter = FIRST_AID_COOLDOWN; firstAidButton.disabled = true; firstAidButton.textContent = `First Aid (${firstAidCooldownCounter})`; logMessage(`<span style='color: lightgreen;'>Recovered ${actualHeal} HP! (Instant)</span>`); updatePlayerStatDisplay(); }
        function handleFleeClick() { if (player.stunTurnsLeft > 0) { logMessage("You are stunned!"); handlePlayerActionTaken(); return; } if (!enemy || enemy.hp <= 0) { logMessage("No enemy."); return; } if (enemy.tier !== 'champion') { logMessage("Can only flee Champions!"); return; } console.log("--- Flee ---"); logMessage("Attempting to flee..."); if (Math.random() < FLEE_CHANCE) { logMessage("<span style='color:yellow;'>Successfully fled!</span>"); spawnEnemy(); handlePlayerActionTaken(); } else { logMessage("<span style='color:red;'>Flee attempt failed!</span>"); handlePlayerActionTaken(); } }

        // --- Item Handling ---
        // Add item to backpack if space allows
        function addItemToBackpack(itemData) {
            if (!itemData) return false;
            if (player.backpack.length < MAX_BACKPACK_SIZE) {
                player.backpack.push(itemData);
                const tierClass = `item-tier-${itemData.tier || 'low'}`;
                logMessage(`<span class="item-drop-message">Added <span class="${tierClass}">${itemData.name || itemData.baseName}</span> to backpack.</span>`);
                displayInventory(); // Update inventory display after adding
                return true;
            } else {
                const tierClass = `item-tier-${itemData.tier || 'low'}`;
                logMessage(`<span style="color:orange;">Backpack full! Could not pick up <span class="${tierClass}">${itemData.name || itemData.baseName}</span>.</span>`);
                return false;
            }
        }

        // Handle enemy defeat (XP, Level Up, Item Drop)
        function handleEnemyDefeat() {
            if (!enemy) return;
            const defeatedEnemyName = enemy.name;
            logMessage(`<span style="color:lime; font-weight:bold;">Defeated ${defeatedEnemyName}!</span>`);
            const xpGained = Number(enemy.xpValue) || 0;
            if (xpGained > 0) { player.xp += xpGained; logMessage(`Gained ${xpGained} XP!`); }
            wasAfterCombat = true;
            const leveledUp = checkLevelUp();
            if (!leveledUp) { updatePlayerStatDisplay(); } // Update display if no level up (level up handles its own update)
            let itemGenerated = false;
            if (defeatedEnemyName === "Metal Slime") { itemGenerated = handleGuaranteedMaxStatDrop(); }
            else if (Math.random() < ITEM_DROP_CHANCE) { itemGenerated = handleItemDrop(); }
            logMessage("Prepare for the next battle...");
            const delay = itemGenerated ? 1500 : 1000;
            setTimeout(() => { spawnEnemy(); decrementCooldowns(); wasAfterCombat = false; }, delay);
            enemy = null;
            updateEnemyStatDisplay();
        }

        // Generate a random item drop and add to backpack
        function handleItemDrop() {
            const playerLevel = player.level;
            let tier = 'low';
            if (playerLevel > TIER_LEVELS.mid) { tier = 'high'; }
            else if (playerLevel > TIER_LEVELS.low) { tier = 'mid'; }
            const possibleCategories = ['weapon', 'armor', 'accessory'];
            const chosenCategory = possibleCategories[getRandomInt(0, possibleCategories.length - 1)];
            const possibleItems = equipmentCatalog[chosenCategory]?.filter(item => item && item.tier === tier) || [];
            if (possibleItems.length > 0) {
                const baseItemData = { ...possibleItems[getRandomInt(0, possibleItems.length - 1)] };
                const droppedItemData = { ...baseItemData };
                if (droppedItemData.category === 'accessory' && droppedItemData.baseName) { droppedItemData.name = generateAccessoryName(droppedItemData.baseName); }
                else if (!droppedItemData.name) { droppedItemData.name = `${tier} ${chosenCategory}`; }
                if (droppedItemData.stats) { droppedItemData.stats = randomizeItemStats(droppedItemData.stats, droppedItemData.category); }
                else { droppedItemData.stats = {}; }
                return addItemToBackpack(droppedItemData);
            } else { console.warn(`No items found for category '${chosenCategory}' tier '${tier}'.`); return false; }
        }

        // Generate a guaranteed high-stat drop and add to backpack
        function handleGuaranteedMaxStatDrop() {
            const tier = 'mid';
            const possibleCategories = ['weapon', 'armor', 'accessory'];
            const chosenCategory = possibleCategories[getRandomInt(0, possibleCategories.length - 1)];
            const possibleItems = equipmentCatalog[chosenCategory]?.filter(item => item && item.tier === tier) || [];
            if (possibleItems.length > 0) {
                const baseItemData = { ...possibleItems[getRandomInt(0, possibleItems.length - 1)] };
                const droppedItemData = { ...baseItemData };
                if (droppedItemData.category === 'accessory' && droppedItemData.baseName) { droppedItemData.name = generateAccessoryName(droppedItemData.baseName); }
                else if (!droppedItemData.name) { droppedItemData.name = `${tier} ${chosenCategory}`; }
                if (droppedItemData.stats) { droppedItemData.stats = randomizeStatsHigh(droppedItemData.stats); }
                else { droppedItemData.stats = {}; }
                return addItemToBackpack(droppedItemData);
            } else { console.warn(`No mid-tier items for Metal Slime drop.`); return false; }
        }

        // --- Inventory UI Functions ---
        // Removed openInventory and closeInventory

        // Populate the inventory display (now always visible)
        function displayInventory() {
            if (!player || !player.equipment || !player.backpack) { console.error("Cannot display inventory: Player data missing."); return; }

            // --- Update Equipped Gear Section ---
            const slots = ['weapon', 'armor', 'accessory'];
            const equippedElements = { weapon: { nameEl: invEquippedWeapon, imgEl: invEquippedWeaponImg }, armor: { nameEl: invEquippedArmor, imgEl: invEquippedArmorImg }, accessory: { nameEl: invEquippedAccessory, imgEl: invEquippedAccessoryImg }, };
            const imagePaths = { weapon: { low: 'Images/LT_1h_sword.jpg', mid: 'Images/MT_1H_sword.png', high: 'Images/HT_1H_sword.jpg', default: 'https://placehold.co/40x40/a52a2a/eee?text=WPN' }, armor: { low: 'Images/LT_leatherarmor.jpg', mid: 'Images/MT_chainmail.jpg', high: 'Images/HT_platemail.jpg', default: 'https://placehold.co/40x40/708090/eee?text=ARM' }, accessory: { low: 'Images/LT_accessories.jpg', mid: 'Images/MT_accessories.jpg', high: 'Images/HT_accessories.jpg', default: 'https://placehold.co/40x40/ffd700/333?text=ACC' } };
            slots.forEach(slot => { const item = player.equipment[slot]; const els = equippedElements[slot]; if (item) { const tierClass = `item-tier-${item.tier || 'low'}`; const name = item.name || item.baseName || "Unknown"; els.nameEl.innerHTML = `${slot.charAt(0).toUpperCase() + slot.slice(1)}: <span class="${tierClass}">${name}</span>`; els.imgEl.src = imagePaths[slot]?.[item.tier] || imagePaths[slot]?.default; els.imgEl.alt = name; } else { els.nameEl.innerHTML = `${slot.charAt(0).toUpperCase() + slot.slice(1)}: <span class="item-tier-low">None</span>`; els.imgEl.src = imagePaths[slot]?.default; els.imgEl.alt = "Empty Slot"; } });

            // --- Update Backpack Grid ---
            backpackGrid.innerHTML = '';
            backpackCountSpan.textContent = player.backpack.length;
            backpackMaxSpan.textContent = MAX_BACKPACK_SIZE;
            for (let i = 0; i < MAX_BACKPACK_SIZE; i++) { const slotDiv = document.createElement('div'); slotDiv.classList.add('backpack-slot'); if (i < player.backpack.length) { const item = player.backpack[i]; const tier = item.tier || 'low'; const category = item.category || 'unknown'; const imgSrc = imagePaths[category]?.[tier] || imagePaths[category]?.default || 'https://placehold.co/40x40/555/eee?text=???'; const img = document.createElement('img'); img.src = imgSrc; img.alt = item.name || item.baseName || category; slotDiv.appendChild(img); slotDiv.dataset.backpackIndex = i; slotDiv.classList.add(`item-tier-${tier}`); slotDiv.addEventListener('click', handleBackpackSlotClick); } else { slotDiv.classList.add('empty'); } backpackGrid.appendChild(slotDiv); }

            // Clear item details initially when refreshing inventory
            clearItemSelection();
        }
        function handleBackpackSlotClick(event) { const targetSlot = event.currentTarget; if (!targetSlot.classList.contains('backpack-slot') || targetSlot.classList.contains('empty')) { clearItemSelection(); return; } const clickedIndex = parseInt(targetSlot.dataset.backpackIndex, 10); if (isNaN(clickedIndex) || clickedIndex < 0 || clickedIndex >= player.backpack.length) { console.warn("Invalid backpack index clicked."); clearItemSelection(); return; } const previouslySelected = backpackGrid.querySelector('.selected'); if (previouslySelected) { previouslySelected.classList.remove('selected'); } targetSlot.classList.add('selected'); selectedBackpackIndex = clickedIndex; showItemDetails(selectedBackpackIndex); }

        // Clear the item details and comparison panes
        function clearItemSelection() {
            equippedItemComparisonDiv.innerHTML = '<h4>Currently Equipped</h4><p>N/A</p>'; // Clear equipped comparison
            selectedItemDetailsDiv.innerHTML = '<h4>Selected Item</h4><p>Select an item from backpack.</p>'; // Clear selected details
            itemDetailActionsDiv.classList.add('hidden'); // Hide buttons
            selectedBackpackIndex = -1; // Reset selected index

            const currentlySelected = backpackGrid.querySelector('.selected');
            if (currentlySelected) {
                currentlySelected.classList.remove('selected');
            }
        }

        // Show details for the selected backpack item and comparison with equipped
        function showItemDetails(index) {
            if (index < 0 || index >= player.backpack.length) { clearItemSelection(); return; }
            const selectedItem = player.backpack[index];
            if (!selectedItem) { clearItemSelection(); return; }

            const slot = selectedItem.category;
            const equippedItem = player.equipment[slot]; // Get currently equipped item in the same slot

            // --- Populate Equipped Item Comparison ---
            let equippedHTML = `<h4>Currently Equipped</h4>`;
            if (equippedItem) {
                const eqTierClass = `item-tier-${equippedItem.tier || 'low'}`;
                equippedHTML += `<h5><span class="${eqTierClass}">${equippedItem.name || equippedItem.baseName}</span></h5>`;
                equippedHTML += `<ul>${generateStatsHTML(equippedItem)}</ul>`;
            } else {
                equippedHTML += `<p>None</p>`;
            }
            equippedItemComparisonDiv.innerHTML = equippedHTML;

            // --- Populate Selected Item Details ---
            const selTierClass = `item-tier-${selectedItem.tier || 'low'}`;
            let selectedHTML = `<h4>Selected Item</h4>`;
            selectedHTML += `<h5><span class="${selTierClass}">${selectedItem.name || selectedItem.baseName}</span></h5>`;
            selectedHTML += `<ul>${generateStatsHTML(selectedItem, equippedItem)}</ul>`; // Pass equipped for comparison
            selectedItemDetailsDiv.innerHTML = selectedHTML;

            itemDetailActionsDiv.classList.remove('hidden'); // Show Equip/Discard buttons
        }

        // Helper function to generate HTML list of stats for an item, optionally comparing
        function generateStatsHTML(item, compareToItem = null) {
            let statsHTML = '';
            let hasStats = false;
            if (item && item.stats) {
                for (const statKey in item.stats) {
                    if (item.stats.hasOwnProperty(statKey)) {
                        const statValue = item.stats[statKey];
                        const numericValue = parseFloat(statValue);
                        if (!isNaN(numericValue) && numericValue !== 0) {
                            hasStats = true;
                            const formattedName = formatStatName(statKey);
                            let formattedValue = "";
                            let comparisonClass = '';

                            // Format value
                            if (statKey === 'dodge' || statKey === 'critChance') {
                                formattedValue = `+${(numericValue * 100).toFixed(1)}%`;
                            } else if (statKey === 'critDamageMultiplier') {
                                formattedValue = `+${Math.round((numericValue - 1) * 100)}%`; // Show bonus %
                            } else {
                                const roundedValue = Number.isInteger(numericValue) ? numericValue : parseFloat(numericValue.toFixed(1));
                                formattedValue = roundedValue > 0 ? `+${roundedValue}` : `${roundedValue}`;
                            }

                            // Add comparison indicators if comparing
                            if (compareToItem && compareToItem.stats && compareToItem.stats.hasOwnProperty(statKey)) {
                                const equippedValue = parseFloat(compareToItem.stats[statKey] || 0);
                                if (numericValue > equippedValue) comparisonClass = 'positive';
                                if (numericValue < equippedValue) comparisonClass = 'negative';
                            }

                            statsHTML += `<li><strong class="${comparisonClass}">${formattedValue}</strong> ${formattedName}</li>`;
                        }
                    }
                }
            }
            if (!hasStats) { statsHTML += "<li>No Stats</li>"; }
            return statsHTML;
        }


        function handleEquipFromBackpack() { if (selectedBackpackIndex < 0 || selectedBackpackIndex >= player.backpack.length) { console.warn("No valid item selected to equip."); return; } const itemToEquip = player.backpack[selectedBackpackIndex]; const slot = itemToEquip.category; if (!slot || !player.equipment.hasOwnProperty(slot)) { console.error(`Cannot equip item: Invalid category "${slot}"`); logMessage(`<span style='color:orange;'>Error: Cannot equip this item type.</span>`); return; } const currentlyEquippedItem = player.equipment[slot]; player.equipment[slot] = itemToEquip; const equipTierClass = `item-tier-${itemToEquip.tier || 'low'}`; logMessage(`Equipped <span class="${equipTierClass}">${itemToEquip.name || itemToEquip.baseName}</span>.`); player.backpack.splice(selectedBackpackIndex, 1); if (currentlyEquippedItem) { addItemToBackpack(currentlyEquippedItem); } calculateTotalStats(); updatePlayerStatDisplay(); displayInventory(); }
        function handleDiscardFromBackpack() { if (selectedBackpackIndex < 0 || selectedBackpackIndex >= player.backpack.length) { console.warn("No valid item selected to discard."); return; } const itemToDiscard = player.backpack[selectedBackpackIndex]; const discardTierClass = `item-tier-${itemToDiscard.tier || 'low'}`; player.backpack.splice(selectedBackpackIndex, 1); logMessage(`Discarded <span class="${discardTierClass}">${itemToDiscard.name || itemToDiscard.baseName}</span>.`); displayInventory(); }

        // --- Game Management ---
        function resetGame() {
            console.log("--- Resetting game ---");
            player = JSON.parse(JSON.stringify(INITIAL_PLAYER_STATE));
            player.equipment = { weapon: null, armor: null, accessory: null };
            player.backpack = [];
            player.baseMaxHp = INITIAL_PLAYER_STATE.maxHp; player.baseStr = INITIAL_PLAYER_STATE.str; player.baseDef = INITIAL_PLAYER_STATE.def; player.baseMinDmg = INITIAL_PLAYER_STATE.minDamage; player.baseMaxDmg = INITIAL_PLAYER_STATE.maxDamage;
            player.baseCritChance = INITIAL_PLAYER_STATE.critChance;
            player.baseCritDamageMultiplier = INITIAL_PLAYER_STATE.critDamageMultiplier;
            player.hp = player.baseMaxHp;
            player.dodgeChance = BASE_DODGE_CHANCE; player.evasionActive = false; player.evasionDuration = 0;
            player.poisonTurnsLeft = 0; player.bleedTurnsLeft = 0; player.bleedDamagePerTurn = 0; player.stunTurnsLeft = 0;
            player.defenseDownTurns = 0; player.defenseDownMultiplier = 1; player.attackDownTurns = 0; player.attackDownMultiplier = 1;
            player.burnTurnsLeft = 0; player.burnDamagePerTurn = 0; player.isDiseased = false;
            firstAidCooldownCounter = 0; evasionCooldownCounter = 0; horizontalArcCooldownCounter = 0; horizontalSquareCooldownCounter = 0; deadlySinsCooldownCounter = 0;
            currentChampionSpawnChance = INITIAL_CHAMPION_SPAWN_CHANCE;
            wasAfterCombat = false;
            selectedBackpackIndex = -1;
            calculateTotalStats(); player.hp = player.maxHp; updatePlayerStatDisplay(); // Calls displayInventory
            const messageContainer = document.getElementById('message');
            if (messageContainer) messageContainer.innerHTML = '';
            logMessage(`Game Reset. Welcome, Player! Prepare for battle!`);
            firstAidButton.disabled = false; firstAidButton.textContent = "First Aid";
            evasionButton.disabled = false; evasionButton.textContent = "Evasion";
            horizontalButton.disabled = false; updateSkillButtons();
             if(fleeButton) { fleeButton.classList.add('hidden'); fleeButton.disabled = true; }
            loadHighScore(); updateHighScoreDisplay();
            spawnEnemy();
            // closeInventory(); // No longer needed
            console.log("--- Game Reset Complete ---", player);
        }
        function handlePlayerChoiceChange(event) { if (event.target.value) { selectedPlayerImage = event.target.value; console.log("Selected player image:", selectedPlayerImage); } }
        function loadHighScore() { const savedScore = localStorage.getItem('aincradHighScore'); highScore = parseInt(savedScore, 10) || 0; console.log(`Loaded high score: ${highScore}`); }
        function saveHighScore() { if (typeof highScore === 'number') { localStorage.setItem('aincradHighScore', highScore.toString()); console.log(`Saved high score: ${highScore}`); } else { console.error("Invalid high score:", highScore); } }
        function updateHighScoreDisplay() { if (highScoreValueElement) { highScoreValueElement.textContent = highScore; } }
        function resetHighScore() { console.log("Resetting high score."); highScore = 0; saveHighScore(); updateHighScoreDisplay(); logMessage("Highest level record reset."); }
        function levelUp() { const oldLevel = player.level; player.level++; logMessage(`<span style="color: yellow; font-weight: bold;">Level Up! Reached Level ${player.level}!</span>`); if (oldLevel < HORIZONTAL_ARC_LEVEL && player.level >= HORIZONTAL_ARC_LEVEL) { logMessage(`<span class="special-message skill-learned-message">Learned: Horizontal Arc!</span>`); } if (oldLevel < HORIZONTAL_SQUARE_LEVEL && player.level >= HORIZONTAL_SQUARE_LEVEL) { logMessage(`<span class="special-message skill-learned-message">Learned: Horizontal Square!</span>`); } if (oldLevel < DEADLY_SINS_LEVEL && player.level >= DEADLY_SINS_LEVEL) { logMessage(`<span class="special-message skill-learned-message">Learned: Deadly Sins!</span>`); } player.baseMaxHp += 10; player.baseStr += getRandomInt(1, 2); player.baseDef += getRandomInt(1, 2); const minDmgIncrease = getRandomInt(1, 2); const maxDmgIncrease = getRandomInt(1, 2); player.baseMinDmg += minDmgIncrease; player.baseMaxDmg += Math.max(minDmgIncrease, maxDmgIncrease); calculateTotalStats(); player.hp = player.maxHp; logMessage("<span style='color:lime;'>HP fully restored!</span>"); player.xpToNextLevel = Math.floor(player.xpToNextLevel * XP_LEVEL_MULTIPLIER); if (player.level > highScore) { highScore = player.level; saveHighScore(); updateHighScoreDisplay(); logMessage(`New highest level: ${highScore}!`); } updatePlayerStatDisplay(); updateSkillButtons(); console.log(`Leveled up to ${player.level}.`); return true; }
        function checkLevelUp() { let leveledUp = false; while (player.xp >= player.xpToNextLevel) { player.xp -= player.xpToNextLevel; leveledUp = levelUp(); } if (player.xp < 0) player.xp = 0; return leveledUp; }
        function updateSkillButtons() { evasionButton.disabled = evasionCooldownCounter > 0; firstAidButton.disabled = firstAidCooldownCounter > 0; const canUseHA = player.level >= HORIZONTAL_ARC_LEVEL; horizontalArcButton.classList.toggle('hidden', !canUseHA); horizontalArcButton.disabled = !canUseHA || horizontalArcCooldownCounter > 0; const canUseHS = player.level >= HORIZONTAL_SQUARE_LEVEL; horizontalSquareButton.classList.toggle('hidden', !canUseHS); horizontalSquareButton.disabled = !canUseHS || horizontalSquareCooldownCounter > 0; const canUseDS = player.level >= DEADLY_SINS_LEVEL; deadlySinsButton.classList.toggle('hidden', !canUseDS); deadlySinsButton.disabled = !canUseDS || deadlySinsCooldownCounter > 0; if (fleeButton) { fleeButton.disabled = !enemy || enemy.tier !== 'champion' || player.hp <= 0; fleeButton.classList.toggle('hidden', !enemy || enemy.tier !== 'champion'); } if (player.hp <= 0) { horizontalButton.disabled = true; horizontalArcButton.disabled = true; horizontalSquareButton.disabled = true; deadlySinsButton.disabled = true; evasionButton.disabled = true; firstAidButton.disabled = true; if(fleeButton) fleeButton.disabled = true; } else if (player.stunTurnsLeft > 0) { horizontalButton.disabled = true; horizontalArcButton.disabled = true; horizontalSquareButton.disabled = true; deadlySinsButton.disabled = true; if(fleeButton) fleeButton.disabled = true; } else { horizontalButton.disabled = false; } }
        function showTooltip(event) { const buttonId = event.target.id; const tooltipData = skillTooltips[buttonId]; if (tooltipData && tooltipElement) { let tooltipHTML = `<strong>${tooltipData.name}</strong>`; if (tooltipData.level > 1) { tooltipHTML += ` (Lvl ${tooltipData.level})`; } tooltipHTML += `<hr style="margin: 4px 0; border-top: 1px solid #7f8c8d;">`; tooltipHTML += `<p style="margin: 2px 0;">${tooltipData.desc}</p>`; tooltipHTML += `<p style="margin: 2px 0;"><em>Effect:</em> ${tooltipData.effect}</p>`; tooltipHTML += `<p style="margin: 2px 0;"><em>Cost:</em> ${tooltipData.cost}</p>`; if (tooltipData.cooldown > 0) { tooltipHTML += `<p style="margin: 2px 0;"><em>Cooldown:</em> ${tooltipData.cooldown} turns</p>`; } tooltipElement.innerHTML = tooltipHTML; tooltipElement.classList.remove('hidden'); updateTooltipPosition(event); document.addEventListener('mousemove', updateTooltipPosition); } else { hideTooltip(); if (!tooltipData) console.warn(`No tooltip data for button: ${buttonId}`); } }
        function hideTooltip() { if (tooltipElement) { tooltipElement.classList.add('hidden'); document.removeEventListener('mousemove', updateTooltipPosition); } }
        function updateTooltipPosition(event) { if (tooltipElement && !tooltipElement.classList.contains('hidden')) { const offsetX = 15; const offsetY = 10; let x = event.pageX + offsetX; let y = event.pageY + offsetY; const tooltipRect = tooltipElement.getBoundingClientRect(); const viewportWidth = document.documentElement.clientWidth; const viewportHeight = document.documentElement.clientHeight; if (x + tooltipRect.width > viewportWidth) { x = event.pageX - tooltipRect.width - offsetX; } if (y + tooltipRect.height > viewportHeight + window.scrollY) { y = event.pageY - tooltipRect.height - offsetY; } if (x < 0) { x = offsetX; } if (y < window.scrollY) { y = window.scrollY + offsetY; } tooltipElement.style.left = `${x}px`; tooltipElement.style.top = `${y}px`; } }

        // --- Event Listeners ---
        // Action Buttons
        horizontalButton.addEventListener('click', handleHorizontalClick);
        evasionButton.addEventListener('click', handleEvasionClick);
        firstAidButton.addEventListener('click', handleFirstAidClick);
        horizontalArcButton.addEventListener('click', handleHorizontalArcClick);
        horizontalSquareButton.addEventListener('click', handleHorizontalSquareClick);
        deadlySinsButton.addEventListener('click', handleDeadlySinsClick);
        if(fleeButton) fleeButton.addEventListener('click', handleFleeClick);
        // Top Control Buttons
        resetButton.addEventListener('click', resetGame);
        newCharacterButton.addEventListener('click', showStartScreen);
        resetHighScoreButton.addEventListener('click', resetHighScore);
        // Start Screen Buttons
        playerChoiceRadios.forEach(radio => { radio.addEventListener('change', handlePlayerChoiceChange); });
        startGameButton.addEventListener('click', () => { showGameScreen(); resetGame(); });
        // Tooltip Listeners
        const actionButtons = [ horizontalButton, evasionButton, firstAidButton, horizontalArcButton, horizontalSquareButton, deadlySinsButton, fleeButton ];
        actionButtons.forEach(button => { if (button) { button.addEventListener('mouseover', showTooltip); button.addEventListener('mouseout', hideTooltip); } });
        // Inventory Action Listeners
        equipButton.addEventListener('click', handleEquipFromBackpack);
        discardButton.addEventListener('click', handleDiscardFromBackpack);


        // --- Initial Setup ---
        console.log("Game script loaded!");
        loadHighScore();
        updateHighScoreDisplay();
        showStartScreen(); // Show start screen initially

    </script>

</body>
</html>
